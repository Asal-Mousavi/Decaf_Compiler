Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    KEYWORD
    TAB

Grammar

Rule 0     S' -> program
Rule 1     program -> CLASS PROGRAM OPEN field_decl method_decl CLOSE
Rule 2     field_decl -> type field_decl_1 SEMI
Rule 3     field_decl -> field_decl field_decl
Rule 4     field_decl -> field_decl NEWLINE
Rule 5     field_decl -> empty
Rule 6     field_decl_1 -> IDENTIFIER
Rule 7     field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET
Rule 8     field_decl_1 -> field_decl_1 COMMA field_decl_1
Rule 9     method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
Rule 10    method_decl -> method_decl NEWLINE
Rule 11    method_decl -> method_decl method_decl
Rule 12    method_decl -> empty
Rule 13    type_and_id -> type IDENTIFIER
Rule 14    type_and_id -> type_and_id COMMA type_and_id
Rule 15    type_or_void -> type
Rule 16    type_or_void -> VOID
Rule 17    block -> OPEN var_decl statement CLOSE
Rule 18    block -> OPEN CLOSE
Rule 19    var_decl -> type var_decl_1 SEMI
Rule 20    var_decl -> var_decl var_decl NEWLINE
Rule 21    var_decl -> empty
Rule 22    var_decl_1 -> IDENTIFIER
Rule 23    var_decl_1 -> var_decl_1 COMMA var_decl_1
Rule 24    type -> INT
Rule 25    type -> BOOLEAN
Rule 26    statement -> location ASSIGN expr SEMI
Rule 27    statement -> method_call SEMI
Rule 28    statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty
Rule 29    statement -> WHILE O_PAR expr C_PAR block
Rule 30    statement -> RETURN expr_or_empty SEMI
Rule 31    statement -> BREAK SEMI
Rule 32    statement -> CONTINUE SEMI
Rule 33    statement -> block
Rule 34    statement -> statement statement
Rule 35    statement -> statement NEWLINE
Rule 36    statement -> empty
Rule 37    expr_or_empty -> expr
Rule 38    expr_or_empty -> empty
Rule 39    else_or_empty -> ELSE block
Rule 40    else_or_empty -> else_or_empty else_or_empty
Rule 41    else_or_empty -> empty
Rule 42    method_call -> method_name O_PAR arg C_PAR
Rule 43    method_call -> CALLOUT O_PAR string_literal C_PAR
Rule 44    method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
Rule 45    method_name -> IDENTIFIER
Rule 46    arg -> expr
Rule 47    arg -> expr COMMA arg
Rule 48    location -> IDENTIFIER
Rule 49    location -> IDENTIFIER O_BRACKET expr C_BRACKET
Rule 50    expr -> location
Rule 51    expr -> method_call
Rule 52    expr -> literal
Rule 53    expr -> expr bin_op expr
Rule 54    expr -> NEGATIVE expr
Rule 55    expr -> EXCL expr
Rule 56    expr -> O_PAR expr C_PAR
Rule 57    expr -> expr expr
Rule 58    expr -> expr NEWLINE
Rule 59    call -> callout_arg
Rule 60    call -> callout_arg call
Rule 61    callout_arg -> expr
Rule 62    callout_arg -> string_literal
Rule 63    callout_arg -> callout_arg
Rule 64    bin_op -> ARITH_OP
Rule 65    bin_op -> REP_OP
Rule 66    bin_op -> EQ_OP
Rule 67    bin_op -> COND_OP
Rule 68    literal -> int_literal
Rule 69    literal -> char_literal
Rule 70    literal -> bool_literal
Rule 71    int_literal -> DECIMAL
Rule 72    int_literal -> HEXDECIMAL
Rule 73    bool_literal -> TRUE
Rule 74    bool_literal -> FALSE
Rule 75    char_literal -> CHAR
Rule 76    string_literal -> STRING
Rule 77    empty -> <empty>

Terminals, with rules where they appear

ARITH_OP             : 64
ASSIGN               : 26
BOOLEAN              : 25
BREAK                : 31
CALLOUT              : 43 44
CHAR                 : 75
CLASS                : 1
CLOSE                : 1 17 18
COMMA                : 8 14 23 44 44 47
COMMENT              : 
COND_OP              : 67
CONTINUE             : 32
C_BRACKET            : 7 49
C_PAR                : 9 28 29 42 43 44 56
DECIMAL              : 71
ELSE                 : 39
EQ_OP                : 66
EXCL                 : 55
FALSE                : 74
HEXDECIMAL           : 72
IDENTIFIER           : 6 7 9 13 22 45 48 49
IF                   : 28
INT                  : 24
KEYWORD              : 
NEGATIVE             : 54
NEWLINE              : 4 10 20 28 35 58
OPEN                 : 1 17 18
O_BRACKET            : 7 49
O_PAR                : 9 28 29 42 43 44 56
PROGRAM              : 1
REP_OP               : 65
RETURN               : 30
SEMI                 : 2 19 26 27 30 31 32
STRING               : 76
TAB                  : 
TRUE                 : 73
VOID                 : 16
WHILE                : 29
error                : 

Nonterminals, with rules where they appear

arg                  : 42 47
bin_op               : 53
block                : 9 28 29 33 39
bool_literal         : 70
call                 : 44 60
callout_arg          : 59 60 63
char_literal         : 69
else_or_empty        : 28 40 40
empty                : 5 12 21 36 38 41
expr                 : 26 28 29 37 46 47 49 53 53 54 55 56 57 57 58 61
expr_or_empty        : 30
field_decl           : 1 3 3 4
field_decl_1         : 2 8 8
int_literal          : 7 68
literal              : 52
location             : 26 50
method_call          : 27 51
method_decl          : 1 10 11 11
method_name          : 42
program              : 0
statement            : 17 34 34 35
string_literal       : 43 44 62
type                 : 2 13 15 19
type_and_id          : 9 14 14
type_or_void         : 9
var_decl             : 17 20 20
var_decl_1           : 19 23 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . CLASS PROGRAM OPEN field_decl method_decl CLOSE

    CLASS           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> CLASS . PROGRAM OPEN field_decl method_decl CLOSE

    PROGRAM         shift and go to state 3


state 3

    (1) program -> CLASS PROGRAM . OPEN field_decl method_decl CLOSE

    OPEN            shift and go to state 4


state 4

    (1) program -> CLASS PROGRAM OPEN . field_decl method_decl CLOSE
    (2) field_decl -> . type field_decl_1 SEMI
    (3) field_decl -> . field_decl field_decl
    (4) field_decl -> . field_decl NEWLINE
    (5) field_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (77) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9
    NEWLINE         reduce using rule 77 (empty -> .)
    VOID            reduce using rule 77 (empty -> .)
    CLOSE           reduce using rule 77 (empty -> .)

  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]

    field_decl                     shift and go to state 5
    type                           shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> CLASS PROGRAM OPEN field_decl . method_decl CLOSE
    (3) field_decl -> field_decl . field_decl
    (4) field_decl -> field_decl . NEWLINE
    (9) method_decl -> . type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
    (10) method_decl -> . method_decl NEWLINE
    (11) method_decl -> . method_decl method_decl
    (12) method_decl -> . empty
    (2) field_decl -> . type field_decl_1 SEMI
    (3) field_decl -> . field_decl field_decl
    (4) field_decl -> . field_decl NEWLINE
    (5) field_decl -> . empty
    (15) type_or_void -> . type
    (16) type_or_void -> . VOID
    (77) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    NEWLINE         shift and go to state 12
    VOID            shift and go to state 16
    CLOSE           reduce using rule 77 (empty -> .)
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! VOID            [ reduce using rule 77 (empty -> .) ]
  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]

    field_decl                     shift and go to state 10
    method_decl                    shift and go to state 11
    type_or_void                   shift and go to state 13
    empty                          shift and go to state 14
    type                           shift and go to state 15

state 6

    (2) field_decl -> type . field_decl_1 SEMI
    (6) field_decl_1 -> . IDENTIFIER
    (7) field_decl_1 -> . IDENTIFIER O_BRACKET int_literal C_BRACKET
    (8) field_decl_1 -> . field_decl_1 COMMA field_decl_1

    IDENTIFIER      shift and go to state 18

    field_decl_1                   shift and go to state 17

state 7

    (5) field_decl -> empty .

    NEWLINE         reduce using rule 5 (field_decl -> empty .)
    VOID            reduce using rule 5 (field_decl -> empty .)
    INT             reduce using rule 5 (field_decl -> empty .)
    BOOLEAN         reduce using rule 5 (field_decl -> empty .)
    CLOSE           reduce using rule 5 (field_decl -> empty .)


state 8

    (24) type -> INT .

    IDENTIFIER      reduce using rule 24 (type -> INT .)


state 9

    (25) type -> BOOLEAN .

    IDENTIFIER      reduce using rule 25 (type -> BOOLEAN .)


state 10

    (3) field_decl -> field_decl field_decl .
    (3) field_decl -> field_decl . field_decl
    (4) field_decl -> field_decl . NEWLINE
    (2) field_decl -> . type field_decl_1 SEMI
    (3) field_decl -> . field_decl field_decl
    (4) field_decl -> . field_decl NEWLINE
    (5) field_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (77) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 3 (field_decl -> field_decl field_decl .)
  ! reduce/reduce conflict for CLOSE resolved using rule 3 (field_decl -> field_decl field_decl .)
    VOID            reduce using rule 3 (field_decl -> field_decl field_decl .)
    CLOSE           reduce using rule 3 (field_decl -> field_decl field_decl .)
    NEWLINE         shift and go to state 12
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 3 (field_decl -> field_decl field_decl .) ]
  ! INT             [ reduce using rule 3 (field_decl -> field_decl field_decl .) ]
  ! BOOLEAN         [ reduce using rule 3 (field_decl -> field_decl field_decl .) ]
  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]
  ! VOID            [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]

    field_decl                     shift and go to state 10
    type                           shift and go to state 6
    empty                          shift and go to state 7

state 11

    (1) program -> CLASS PROGRAM OPEN field_decl method_decl . CLOSE
    (10) method_decl -> method_decl . NEWLINE
    (11) method_decl -> method_decl . method_decl
    (9) method_decl -> . type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
    (10) method_decl -> . method_decl NEWLINE
    (11) method_decl -> . method_decl method_decl
    (12) method_decl -> . empty
    (15) type_or_void -> . type
    (16) type_or_void -> . VOID
    (77) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for CLOSE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    CLOSE           shift and go to state 20
    NEWLINE         shift and go to state 21
    VOID            shift and go to state 16
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! VOID            [ reduce using rule 77 (empty -> .) ]
  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]

    method_decl                    shift and go to state 19
    type_or_void                   shift and go to state 13
    empty                          shift and go to state 22
    type                           shift and go to state 23

state 12

    (4) field_decl -> field_decl NEWLINE .

    NEWLINE         reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    VOID            reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    INT             reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    BOOLEAN         reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    CLOSE           reduce using rule 4 (field_decl -> field_decl NEWLINE .)


state 13

    (9) method_decl -> type_or_void . IDENTIFIER O_PAR type_and_id C_PAR block

    IDENTIFIER      shift and go to state 24


state 14

    (12) method_decl -> empty .
    (5) field_decl -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for VOID resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for CLOSE resolved using rule 5 (field_decl -> empty .)
    NEWLINE         reduce using rule 5 (field_decl -> empty .)
    INT             reduce using rule 5 (field_decl -> empty .)
    BOOLEAN         reduce using rule 5 (field_decl -> empty .)
    VOID            reduce using rule 5 (field_decl -> empty .)
    CLOSE           reduce using rule 5 (field_decl -> empty .)

  ! CLOSE           [ reduce using rule 12 (method_decl -> empty .) ]
  ! NEWLINE         [ reduce using rule 12 (method_decl -> empty .) ]
  ! VOID            [ reduce using rule 12 (method_decl -> empty .) ]
  ! INT             [ reduce using rule 12 (method_decl -> empty .) ]
  ! BOOLEAN         [ reduce using rule 12 (method_decl -> empty .) ]


state 15

    (2) field_decl -> type . field_decl_1 SEMI
    (15) type_or_void -> type .
    (6) field_decl_1 -> . IDENTIFIER
    (7) field_decl_1 -> . IDENTIFIER O_BRACKET int_literal C_BRACKET
    (8) field_decl_1 -> . field_decl_1 COMMA field_decl_1

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 18

  ! IDENTIFIER      [ reduce using rule 15 (type_or_void -> type .) ]

    field_decl_1                   shift and go to state 17

state 16

    (16) type_or_void -> VOID .

    IDENTIFIER      reduce using rule 16 (type_or_void -> VOID .)


state 17

    (2) field_decl -> type field_decl_1 . SEMI
    (8) field_decl_1 -> field_decl_1 . COMMA field_decl_1

    SEMI            shift and go to state 25
    COMMA           shift and go to state 26


state 18

    (6) field_decl_1 -> IDENTIFIER .
    (7) field_decl_1 -> IDENTIFIER . O_BRACKET int_literal C_BRACKET

    SEMI            reduce using rule 6 (field_decl_1 -> IDENTIFIER .)
    COMMA           reduce using rule 6 (field_decl_1 -> IDENTIFIER .)
    O_BRACKET       shift and go to state 27


state 19

    (11) method_decl -> method_decl method_decl .
    (10) method_decl -> method_decl . NEWLINE
    (11) method_decl -> method_decl . method_decl
    (9) method_decl -> . type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
    (10) method_decl -> . method_decl NEWLINE
    (11) method_decl -> . method_decl method_decl
    (12) method_decl -> . empty
    (15) type_or_void -> . type
    (16) type_or_void -> . VOID
    (77) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! reduce/reduce conflict for INT resolved using rule 11 (method_decl -> method_decl method_decl .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 11 (method_decl -> method_decl method_decl .)
  ! reduce/reduce conflict for CLOSE resolved using rule 11 (method_decl -> method_decl method_decl .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    CLOSE           reduce using rule 11 (method_decl -> method_decl method_decl .)
    NEWLINE         shift and go to state 21
    VOID            shift and go to state 16
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! VOID            [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! INT             [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! BOOLEAN         [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! VOID            [ reduce using rule 77 (empty -> .) ]
  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]

    method_decl                    shift and go to state 19
    type_or_void                   shift and go to state 13
    empty                          shift and go to state 22
    type                           shift and go to state 23

state 20

    (1) program -> CLASS PROGRAM OPEN field_decl method_decl CLOSE .

    $end            reduce using rule 1 (program -> CLASS PROGRAM OPEN field_decl method_decl CLOSE .)


state 21

    (10) method_decl -> method_decl NEWLINE .

    CLOSE           reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    NEWLINE         reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    VOID            reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    INT             reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    BOOLEAN         reduce using rule 10 (method_decl -> method_decl NEWLINE .)


state 22

    (12) method_decl -> empty .

    NEWLINE         reduce using rule 12 (method_decl -> empty .)
    VOID            reduce using rule 12 (method_decl -> empty .)
    INT             reduce using rule 12 (method_decl -> empty .)
    BOOLEAN         reduce using rule 12 (method_decl -> empty .)
    CLOSE           reduce using rule 12 (method_decl -> empty .)


state 23

    (15) type_or_void -> type .

    IDENTIFIER      reduce using rule 15 (type_or_void -> type .)


state 24

    (9) method_decl -> type_or_void IDENTIFIER . O_PAR type_and_id C_PAR block

    O_PAR           shift and go to state 28


state 25

    (2) field_decl -> type field_decl_1 SEMI .

    NEWLINE         reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    VOID            reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    INT             reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    BOOLEAN         reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    CLOSE           reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)


state 26

    (8) field_decl_1 -> field_decl_1 COMMA . field_decl_1
    (6) field_decl_1 -> . IDENTIFIER
    (7) field_decl_1 -> . IDENTIFIER O_BRACKET int_literal C_BRACKET
    (8) field_decl_1 -> . field_decl_1 COMMA field_decl_1

    IDENTIFIER      shift and go to state 18

    field_decl_1                   shift and go to state 29

state 27

    (7) field_decl_1 -> IDENTIFIER O_BRACKET . int_literal C_BRACKET
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL

    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32

    int_literal                    shift and go to state 30

state 28

    (9) method_decl -> type_or_void IDENTIFIER O_PAR . type_and_id C_PAR block
    (13) type_and_id -> . type IDENTIFIER
    (14) type_and_id -> . type_and_id COMMA type_and_id
    (24) type -> . INT
    (25) type -> . BOOLEAN

    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

    type_and_id                    shift and go to state 33
    type                           shift and go to state 34

state 29

    (8) field_decl_1 -> field_decl_1 COMMA field_decl_1 .
    (8) field_decl_1 -> field_decl_1 . COMMA field_decl_1

  ! shift/reduce conflict for COMMA resolved as shift
    SEMI            reduce using rule 8 (field_decl_1 -> field_decl_1 COMMA field_decl_1 .)
    COMMA           shift and go to state 26

  ! COMMA           [ reduce using rule 8 (field_decl_1 -> field_decl_1 COMMA field_decl_1 .) ]


state 30

    (7) field_decl_1 -> IDENTIFIER O_BRACKET int_literal . C_BRACKET

    C_BRACKET       shift and go to state 35


state 31

    (71) int_literal -> DECIMAL .

    C_BRACKET       reduce using rule 71 (int_literal -> DECIMAL .)
    NEWLINE         reduce using rule 71 (int_literal -> DECIMAL .)
    ARITH_OP        reduce using rule 71 (int_literal -> DECIMAL .)
    REP_OP          reduce using rule 71 (int_literal -> DECIMAL .)
    EQ_OP           reduce using rule 71 (int_literal -> DECIMAL .)
    COND_OP         reduce using rule 71 (int_literal -> DECIMAL .)
    NEGATIVE        reduce using rule 71 (int_literal -> DECIMAL .)
    EXCL            reduce using rule 71 (int_literal -> DECIMAL .)
    O_PAR           reduce using rule 71 (int_literal -> DECIMAL .)
    IDENTIFIER      reduce using rule 71 (int_literal -> DECIMAL .)
    CALLOUT         reduce using rule 71 (int_literal -> DECIMAL .)
    DECIMAL         reduce using rule 71 (int_literal -> DECIMAL .)
    HEXDECIMAL      reduce using rule 71 (int_literal -> DECIMAL .)
    CHAR            reduce using rule 71 (int_literal -> DECIMAL .)
    TRUE            reduce using rule 71 (int_literal -> DECIMAL .)
    FALSE           reduce using rule 71 (int_literal -> DECIMAL .)
    SEMI            reduce using rule 71 (int_literal -> DECIMAL .)
    C_PAR           reduce using rule 71 (int_literal -> DECIMAL .)
    COMMA           reduce using rule 71 (int_literal -> DECIMAL .)
    STRING          reduce using rule 71 (int_literal -> DECIMAL .)


state 32

    (72) int_literal -> HEXDECIMAL .

    C_BRACKET       reduce using rule 72 (int_literal -> HEXDECIMAL .)
    NEWLINE         reduce using rule 72 (int_literal -> HEXDECIMAL .)
    ARITH_OP        reduce using rule 72 (int_literal -> HEXDECIMAL .)
    REP_OP          reduce using rule 72 (int_literal -> HEXDECIMAL .)
    EQ_OP           reduce using rule 72 (int_literal -> HEXDECIMAL .)
    COND_OP         reduce using rule 72 (int_literal -> HEXDECIMAL .)
    NEGATIVE        reduce using rule 72 (int_literal -> HEXDECIMAL .)
    EXCL            reduce using rule 72 (int_literal -> HEXDECIMAL .)
    O_PAR           reduce using rule 72 (int_literal -> HEXDECIMAL .)
    IDENTIFIER      reduce using rule 72 (int_literal -> HEXDECIMAL .)
    CALLOUT         reduce using rule 72 (int_literal -> HEXDECIMAL .)
    DECIMAL         reduce using rule 72 (int_literal -> HEXDECIMAL .)
    HEXDECIMAL      reduce using rule 72 (int_literal -> HEXDECIMAL .)
    CHAR            reduce using rule 72 (int_literal -> HEXDECIMAL .)
    TRUE            reduce using rule 72 (int_literal -> HEXDECIMAL .)
    FALSE           reduce using rule 72 (int_literal -> HEXDECIMAL .)
    SEMI            reduce using rule 72 (int_literal -> HEXDECIMAL .)
    C_PAR           reduce using rule 72 (int_literal -> HEXDECIMAL .)
    COMMA           reduce using rule 72 (int_literal -> HEXDECIMAL .)
    STRING          reduce using rule 72 (int_literal -> HEXDECIMAL .)


state 33

    (9) method_decl -> type_or_void IDENTIFIER O_PAR type_and_id . C_PAR block
    (14) type_and_id -> type_and_id . COMMA type_and_id

    C_PAR           shift and go to state 36
    COMMA           shift and go to state 37


state 34

    (13) type_and_id -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 38


state 35

    (7) field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET .

    SEMI            reduce using rule 7 (field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET .)
    COMMA           reduce using rule 7 (field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET .)


state 36

    (9) method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR . block
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 39

state 37

    (14) type_and_id -> type_and_id COMMA . type_and_id
    (13) type_and_id -> . type IDENTIFIER
    (14) type_and_id -> . type_and_id COMMA type_and_id
    (24) type -> . INT
    (25) type -> . BOOLEAN

    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

    type_and_id                    shift and go to state 41
    type                           shift and go to state 34

state 38

    (13) type_and_id -> type IDENTIFIER .

    C_PAR           reduce using rule 13 (type_and_id -> type IDENTIFIER .)
    COMMA           reduce using rule 13 (type_and_id -> type IDENTIFIER .)


state 39

    (9) method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .

    CLOSE           reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    NEWLINE         reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    VOID            reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    INT             reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    BOOLEAN         reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)


state 40

    (17) block -> OPEN . var_decl statement CLOSE
    (18) block -> OPEN . CLOSE
    (19) var_decl -> . type var_decl_1 SEMI
    (20) var_decl -> . var_decl var_decl NEWLINE
    (21) var_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (77) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for CLOSE resolved as shift
    CLOSE           shift and go to state 43
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9
    IF              reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    BREAK           reduce using rule 77 (empty -> .)
    CONTINUE        reduce using rule 77 (empty -> .)
    IDENTIFIER      reduce using rule 77 (empty -> .)
    CALLOUT         reduce using rule 77 (empty -> .)
    OPEN            reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)

  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]

    var_decl                       shift and go to state 42
    type                           shift and go to state 44
    empty                          shift and go to state 45

state 41

    (14) type_and_id -> type_and_id COMMA type_and_id .
    (14) type_and_id -> type_and_id . COMMA type_and_id

  ! shift/reduce conflict for COMMA resolved as shift
    C_PAR           reduce using rule 14 (type_and_id -> type_and_id COMMA type_and_id .)
    COMMA           shift and go to state 37

  ! COMMA           [ reduce using rule 14 (type_and_id -> type_and_id COMMA type_and_id .) ]


state 42

    (17) block -> OPEN var_decl . statement CLOSE
    (20) var_decl -> var_decl . var_decl NEWLINE
    (26) statement -> . location ASSIGN expr SEMI
    (27) statement -> . method_call SEMI
    (28) statement -> . IF O_PAR expr C_PAR block NEWLINE else_or_empty
    (29) statement -> . WHILE O_PAR expr C_PAR block
    (30) statement -> . RETURN expr_or_empty SEMI
    (31) statement -> . BREAK SEMI
    (32) statement -> . CONTINUE SEMI
    (33) statement -> . block
    (34) statement -> . statement statement
    (35) statement -> . statement NEWLINE
    (36) statement -> . empty
    (19) var_decl -> . type var_decl_1 SEMI
    (20) var_decl -> . var_decl var_decl NEWLINE
    (21) var_decl -> . empty
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE
    (77) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (45) method_name -> . IDENTIFIER

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    IF              shift and go to state 50
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    BREAK           shift and go to state 54
    CONTINUE        shift and go to state 55
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    OPEN            shift and go to state 40
    CLOSE           reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! IF              [ reduce using rule 77 (empty -> .) ]
  ! WHILE           [ reduce using rule 77 (empty -> .) ]
  ! RETURN          [ reduce using rule 77 (empty -> .) ]
  ! BREAK           [ reduce using rule 77 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 77 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 77 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 77 (empty -> .) ]
  ! OPEN            [ reduce using rule 77 (empty -> .) ]
  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]

    var_decl                       shift and go to state 46
    statement                      shift and go to state 47
    location                       shift and go to state 48
    method_call                    shift and go to state 49
    block                          shift and go to state 51
    empty                          shift and go to state 56
    type                           shift and go to state 44
    method_name                    shift and go to state 58

state 43

    (18) block -> OPEN CLOSE .

    CLOSE           reduce using rule 18 (block -> OPEN CLOSE .)
    NEWLINE         reduce using rule 18 (block -> OPEN CLOSE .)
    VOID            reduce using rule 18 (block -> OPEN CLOSE .)
    INT             reduce using rule 18 (block -> OPEN CLOSE .)
    BOOLEAN         reduce using rule 18 (block -> OPEN CLOSE .)
    IF              reduce using rule 18 (block -> OPEN CLOSE .)
    WHILE           reduce using rule 18 (block -> OPEN CLOSE .)
    RETURN          reduce using rule 18 (block -> OPEN CLOSE .)
    BREAK           reduce using rule 18 (block -> OPEN CLOSE .)
    CONTINUE        reduce using rule 18 (block -> OPEN CLOSE .)
    IDENTIFIER      reduce using rule 18 (block -> OPEN CLOSE .)
    CALLOUT         reduce using rule 18 (block -> OPEN CLOSE .)
    OPEN            reduce using rule 18 (block -> OPEN CLOSE .)
    ELSE            reduce using rule 18 (block -> OPEN CLOSE .)


state 44

    (19) var_decl -> type . var_decl_1 SEMI
    (22) var_decl_1 -> . IDENTIFIER
    (23) var_decl_1 -> . var_decl_1 COMMA var_decl_1

    IDENTIFIER      shift and go to state 61

    var_decl_1                     shift and go to state 60

state 45

    (21) var_decl -> empty .

    IF              reduce using rule 21 (var_decl -> empty .)
    WHILE           reduce using rule 21 (var_decl -> empty .)
    RETURN          reduce using rule 21 (var_decl -> empty .)
    BREAK           reduce using rule 21 (var_decl -> empty .)
    CONTINUE        reduce using rule 21 (var_decl -> empty .)
    IDENTIFIER      reduce using rule 21 (var_decl -> empty .)
    CALLOUT         reduce using rule 21 (var_decl -> empty .)
    OPEN            reduce using rule 21 (var_decl -> empty .)
    INT             reduce using rule 21 (var_decl -> empty .)
    BOOLEAN         reduce using rule 21 (var_decl -> empty .)
    CLOSE           reduce using rule 21 (var_decl -> empty .)
    NEWLINE         reduce using rule 21 (var_decl -> empty .)


state 46

    (20) var_decl -> var_decl var_decl . NEWLINE
    (20) var_decl -> var_decl . var_decl NEWLINE
    (19) var_decl -> . type var_decl_1 SEMI
    (20) var_decl -> . var_decl var_decl NEWLINE
    (21) var_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (77) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    NEWLINE         shift and go to state 62
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! INT             [ reduce using rule 77 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 77 (empty -> .) ]

    var_decl                       shift and go to state 46
    type                           shift and go to state 44
    empty                          shift and go to state 45

state 47

    (17) block -> OPEN var_decl statement . CLOSE
    (34) statement -> statement . statement
    (35) statement -> statement . NEWLINE
    (26) statement -> . location ASSIGN expr SEMI
    (27) statement -> . method_call SEMI
    (28) statement -> . IF O_PAR expr C_PAR block NEWLINE else_or_empty
    (29) statement -> . WHILE O_PAR expr C_PAR block
    (30) statement -> . RETURN expr_or_empty SEMI
    (31) statement -> . BREAK SEMI
    (32) statement -> . CONTINUE SEMI
    (33) statement -> . block
    (34) statement -> . statement statement
    (35) statement -> . statement NEWLINE
    (36) statement -> . empty
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE
    (77) empty -> .
    (45) method_name -> . IDENTIFIER

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! shift/reduce conflict for CLOSE resolved as shift
    CLOSE           shift and go to state 64
    NEWLINE         shift and go to state 65
    IF              shift and go to state 50
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    BREAK           shift and go to state 54
    CONTINUE        shift and go to state 55
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    OPEN            shift and go to state 40

  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! IF              [ reduce using rule 77 (empty -> .) ]
  ! WHILE           [ reduce using rule 77 (empty -> .) ]
  ! RETURN          [ reduce using rule 77 (empty -> .) ]
  ! BREAK           [ reduce using rule 77 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 77 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 77 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 77 (empty -> .) ]
  ! OPEN            [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]

    statement                      shift and go to state 63
    location                       shift and go to state 48
    method_call                    shift and go to state 49
    block                          shift and go to state 51
    empty                          shift and go to state 66
    method_name                    shift and go to state 58

state 48

    (26) statement -> location . ASSIGN expr SEMI

    ASSIGN          shift and go to state 67


state 49

    (27) statement -> method_call . SEMI

    SEMI            shift and go to state 68


state 50

    (28) statement -> IF . O_PAR expr C_PAR block NEWLINE else_or_empty

    O_PAR           shift and go to state 69


state 51

    (33) statement -> block .

    CLOSE           reduce using rule 33 (statement -> block .)
    NEWLINE         reduce using rule 33 (statement -> block .)
    IF              reduce using rule 33 (statement -> block .)
    WHILE           reduce using rule 33 (statement -> block .)
    RETURN          reduce using rule 33 (statement -> block .)
    BREAK           reduce using rule 33 (statement -> block .)
    CONTINUE        reduce using rule 33 (statement -> block .)
    IDENTIFIER      reduce using rule 33 (statement -> block .)
    CALLOUT         reduce using rule 33 (statement -> block .)
    OPEN            reduce using rule 33 (statement -> block .)


state 52

    (29) statement -> WHILE . O_PAR expr C_PAR block

    O_PAR           shift and go to state 70


state 53

    (30) statement -> RETURN . expr_or_empty SEMI
    (37) expr_or_empty -> . expr
    (38) expr_or_empty -> . empty
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (77) empty -> .
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    SEMI            reduce using rule 77 (empty -> .)
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr_or_empty                  shift and go to state 71
    expr                           shift and go to state 72
    empty                          shift and go to state 73
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 54

    (31) statement -> BREAK . SEMI

    SEMI            shift and go to state 86


state 55

    (32) statement -> CONTINUE . SEMI

    SEMI            shift and go to state 87


state 56

    (36) statement -> empty .
    (21) var_decl -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 21 (var_decl -> empty .)
    CLOSE           reduce using rule 36 (statement -> empty .)
    IF              reduce using rule 36 (statement -> empty .)
    WHILE           reduce using rule 36 (statement -> empty .)
    RETURN          reduce using rule 36 (statement -> empty .)
    BREAK           reduce using rule 36 (statement -> empty .)
    CONTINUE        reduce using rule 36 (statement -> empty .)
    IDENTIFIER      reduce using rule 36 (statement -> empty .)
    CALLOUT         reduce using rule 36 (statement -> empty .)
    OPEN            reduce using rule 36 (statement -> empty .)
    NEWLINE         reduce using rule 21 (var_decl -> empty .)
    INT             reduce using rule 21 (var_decl -> empty .)
    BOOLEAN         reduce using rule 21 (var_decl -> empty .)

  ! NEWLINE         [ reduce using rule 36 (statement -> empty .) ]


state 57

    (48) location -> IDENTIFIER .
    (49) location -> IDENTIFIER . O_BRACKET expr C_BRACKET
    (45) method_name -> IDENTIFIER .

  ! reduce/reduce conflict for O_PAR resolved using rule 45 (method_name -> IDENTIFIER .)
    ASSIGN          reduce using rule 48 (location -> IDENTIFIER .)
    NEWLINE         reduce using rule 48 (location -> IDENTIFIER .)
    ARITH_OP        reduce using rule 48 (location -> IDENTIFIER .)
    REP_OP          reduce using rule 48 (location -> IDENTIFIER .)
    EQ_OP           reduce using rule 48 (location -> IDENTIFIER .)
    COND_OP         reduce using rule 48 (location -> IDENTIFIER .)
    NEGATIVE        reduce using rule 48 (location -> IDENTIFIER .)
    EXCL            reduce using rule 48 (location -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 48 (location -> IDENTIFIER .)
    CALLOUT         reduce using rule 48 (location -> IDENTIFIER .)
    DECIMAL         reduce using rule 48 (location -> IDENTIFIER .)
    HEXDECIMAL      reduce using rule 48 (location -> IDENTIFIER .)
    CHAR            reduce using rule 48 (location -> IDENTIFIER .)
    TRUE            reduce using rule 48 (location -> IDENTIFIER .)
    FALSE           reduce using rule 48 (location -> IDENTIFIER .)
    SEMI            reduce using rule 48 (location -> IDENTIFIER .)
    C_PAR           reduce using rule 48 (location -> IDENTIFIER .)
    C_BRACKET       reduce using rule 48 (location -> IDENTIFIER .)
    COMMA           reduce using rule 48 (location -> IDENTIFIER .)
    STRING          reduce using rule 48 (location -> IDENTIFIER .)
    O_BRACKET       shift and go to state 88
    O_PAR           reduce using rule 45 (method_name -> IDENTIFIER .)

  ! O_PAR           [ reduce using rule 48 (location -> IDENTIFIER .) ]


state 58

    (42) method_call -> method_name . O_PAR arg C_PAR

    O_PAR           shift and go to state 89


state 59

    (43) method_call -> CALLOUT . O_PAR string_literal C_PAR
    (44) method_call -> CALLOUT . O_PAR string_literal COMMA call COMMA C_PAR

    O_PAR           shift and go to state 90


state 60

    (19) var_decl -> type var_decl_1 . SEMI
    (23) var_decl_1 -> var_decl_1 . COMMA var_decl_1

    SEMI            shift and go to state 91
    COMMA           shift and go to state 92


state 61

    (22) var_decl_1 -> IDENTIFIER .

    SEMI            reduce using rule 22 (var_decl_1 -> IDENTIFIER .)
    COMMA           reduce using rule 22 (var_decl_1 -> IDENTIFIER .)


state 62

    (20) var_decl -> var_decl var_decl NEWLINE .

    IF              reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    WHILE           reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    RETURN          reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    BREAK           reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    CONTINUE        reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    IDENTIFIER      reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    CALLOUT         reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    OPEN            reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    INT             reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    BOOLEAN         reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    CLOSE           reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    NEWLINE         reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)


state 63

    (34) statement -> statement statement .
    (34) statement -> statement . statement
    (35) statement -> statement . NEWLINE
    (26) statement -> . location ASSIGN expr SEMI
    (27) statement -> . method_call SEMI
    (28) statement -> . IF O_PAR expr C_PAR block NEWLINE else_or_empty
    (29) statement -> . WHILE O_PAR expr C_PAR block
    (30) statement -> . RETURN expr_or_empty SEMI
    (31) statement -> . BREAK SEMI
    (32) statement -> . CONTINUE SEMI
    (33) statement -> . block
    (34) statement -> . statement statement
    (35) statement -> . statement NEWLINE
    (36) statement -> . empty
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE
    (77) empty -> .
    (45) method_name -> . IDENTIFIER

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! reduce/reduce conflict for CLOSE resolved using rule 34 (statement -> statement statement .)
    CLOSE           reduce using rule 34 (statement -> statement statement .)
    NEWLINE         shift and go to state 65
    IF              shift and go to state 50
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    BREAK           shift and go to state 54
    CONTINUE        shift and go to state 55
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    OPEN            shift and go to state 40

  ! NEWLINE         [ reduce using rule 34 (statement -> statement statement .) ]
  ! IF              [ reduce using rule 34 (statement -> statement statement .) ]
  ! WHILE           [ reduce using rule 34 (statement -> statement statement .) ]
  ! RETURN          [ reduce using rule 34 (statement -> statement statement .) ]
  ! BREAK           [ reduce using rule 34 (statement -> statement statement .) ]
  ! CONTINUE        [ reduce using rule 34 (statement -> statement statement .) ]
  ! IDENTIFIER      [ reduce using rule 34 (statement -> statement statement .) ]
  ! CALLOUT         [ reduce using rule 34 (statement -> statement statement .) ]
  ! OPEN            [ reduce using rule 34 (statement -> statement statement .) ]
  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! IF              [ reduce using rule 77 (empty -> .) ]
  ! WHILE           [ reduce using rule 77 (empty -> .) ]
  ! RETURN          [ reduce using rule 77 (empty -> .) ]
  ! BREAK           [ reduce using rule 77 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 77 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 77 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 77 (empty -> .) ]
  ! OPEN            [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]

    statement                      shift and go to state 63
    location                       shift and go to state 48
    method_call                    shift and go to state 49
    block                          shift and go to state 51
    empty                          shift and go to state 66
    method_name                    shift and go to state 58

state 64

    (17) block -> OPEN var_decl statement CLOSE .

    CLOSE           reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    NEWLINE         reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    VOID            reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    INT             reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    BOOLEAN         reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    IF              reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    WHILE           reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    RETURN          reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    BREAK           reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    CONTINUE        reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    IDENTIFIER      reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    CALLOUT         reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    OPEN            reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    ELSE            reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)


state 65

    (35) statement -> statement NEWLINE .

    CLOSE           reduce using rule 35 (statement -> statement NEWLINE .)
    NEWLINE         reduce using rule 35 (statement -> statement NEWLINE .)
    IF              reduce using rule 35 (statement -> statement NEWLINE .)
    WHILE           reduce using rule 35 (statement -> statement NEWLINE .)
    RETURN          reduce using rule 35 (statement -> statement NEWLINE .)
    BREAK           reduce using rule 35 (statement -> statement NEWLINE .)
    CONTINUE        reduce using rule 35 (statement -> statement NEWLINE .)
    IDENTIFIER      reduce using rule 35 (statement -> statement NEWLINE .)
    CALLOUT         reduce using rule 35 (statement -> statement NEWLINE .)
    OPEN            reduce using rule 35 (statement -> statement NEWLINE .)


state 66

    (36) statement -> empty .

    NEWLINE         reduce using rule 36 (statement -> empty .)
    IF              reduce using rule 36 (statement -> empty .)
    WHILE           reduce using rule 36 (statement -> empty .)
    RETURN          reduce using rule 36 (statement -> empty .)
    BREAK           reduce using rule 36 (statement -> empty .)
    CONTINUE        reduce using rule 36 (statement -> empty .)
    IDENTIFIER      reduce using rule 36 (statement -> empty .)
    CALLOUT         reduce using rule 36 (statement -> empty .)
    OPEN            reduce using rule 36 (statement -> empty .)
    CLOSE           reduce using rule 36 (statement -> empty .)


state 67

    (26) statement -> location ASSIGN . expr SEMI
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    location                       shift and go to state 74
    expr                           shift and go to state 93
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 68

    (27) statement -> method_call SEMI .

    CLOSE           reduce using rule 27 (statement -> method_call SEMI .)
    NEWLINE         reduce using rule 27 (statement -> method_call SEMI .)
    IF              reduce using rule 27 (statement -> method_call SEMI .)
    WHILE           reduce using rule 27 (statement -> method_call SEMI .)
    RETURN          reduce using rule 27 (statement -> method_call SEMI .)
    BREAK           reduce using rule 27 (statement -> method_call SEMI .)
    CONTINUE        reduce using rule 27 (statement -> method_call SEMI .)
    IDENTIFIER      reduce using rule 27 (statement -> method_call SEMI .)
    CALLOUT         reduce using rule 27 (statement -> method_call SEMI .)
    OPEN            reduce using rule 27 (statement -> method_call SEMI .)


state 69

    (28) statement -> IF O_PAR . expr C_PAR block NEWLINE else_or_empty
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 94
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 70

    (29) statement -> WHILE O_PAR . expr C_PAR block
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 95
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 71

    (30) statement -> RETURN expr_or_empty . SEMI

    SEMI            shift and go to state 96


state 72

    (37) expr_or_empty -> expr .
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    SEMI            reduce using rule 37 (expr_or_empty -> expr .)
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 73

    (38) expr_or_empty -> empty .

    SEMI            reduce using rule 38 (expr_or_empty -> empty .)


state 74

    (50) expr -> location .

    NEWLINE         reduce using rule 50 (expr -> location .)
    ARITH_OP        reduce using rule 50 (expr -> location .)
    REP_OP          reduce using rule 50 (expr -> location .)
    EQ_OP           reduce using rule 50 (expr -> location .)
    COND_OP         reduce using rule 50 (expr -> location .)
    NEGATIVE        reduce using rule 50 (expr -> location .)
    EXCL            reduce using rule 50 (expr -> location .)
    O_PAR           reduce using rule 50 (expr -> location .)
    IDENTIFIER      reduce using rule 50 (expr -> location .)
    CALLOUT         reduce using rule 50 (expr -> location .)
    DECIMAL         reduce using rule 50 (expr -> location .)
    HEXDECIMAL      reduce using rule 50 (expr -> location .)
    CHAR            reduce using rule 50 (expr -> location .)
    TRUE            reduce using rule 50 (expr -> location .)
    FALSE           reduce using rule 50 (expr -> location .)
    SEMI            reduce using rule 50 (expr -> location .)
    C_PAR           reduce using rule 50 (expr -> location .)
    C_BRACKET       reduce using rule 50 (expr -> location .)
    COMMA           reduce using rule 50 (expr -> location .)
    STRING          reduce using rule 50 (expr -> location .)


state 75

    (51) expr -> method_call .

    NEWLINE         reduce using rule 51 (expr -> method_call .)
    ARITH_OP        reduce using rule 51 (expr -> method_call .)
    REP_OP          reduce using rule 51 (expr -> method_call .)
    EQ_OP           reduce using rule 51 (expr -> method_call .)
    COND_OP         reduce using rule 51 (expr -> method_call .)
    NEGATIVE        reduce using rule 51 (expr -> method_call .)
    EXCL            reduce using rule 51 (expr -> method_call .)
    O_PAR           reduce using rule 51 (expr -> method_call .)
    IDENTIFIER      reduce using rule 51 (expr -> method_call .)
    CALLOUT         reduce using rule 51 (expr -> method_call .)
    DECIMAL         reduce using rule 51 (expr -> method_call .)
    HEXDECIMAL      reduce using rule 51 (expr -> method_call .)
    CHAR            reduce using rule 51 (expr -> method_call .)
    TRUE            reduce using rule 51 (expr -> method_call .)
    FALSE           reduce using rule 51 (expr -> method_call .)
    SEMI            reduce using rule 51 (expr -> method_call .)
    C_PAR           reduce using rule 51 (expr -> method_call .)
    C_BRACKET       reduce using rule 51 (expr -> method_call .)
    COMMA           reduce using rule 51 (expr -> method_call .)
    STRING          reduce using rule 51 (expr -> method_call .)


state 76

    (52) expr -> literal .

    NEWLINE         reduce using rule 52 (expr -> literal .)
    ARITH_OP        reduce using rule 52 (expr -> literal .)
    REP_OP          reduce using rule 52 (expr -> literal .)
    EQ_OP           reduce using rule 52 (expr -> literal .)
    COND_OP         reduce using rule 52 (expr -> literal .)
    NEGATIVE        reduce using rule 52 (expr -> literal .)
    EXCL            reduce using rule 52 (expr -> literal .)
    O_PAR           reduce using rule 52 (expr -> literal .)
    IDENTIFIER      reduce using rule 52 (expr -> literal .)
    CALLOUT         reduce using rule 52 (expr -> literal .)
    DECIMAL         reduce using rule 52 (expr -> literal .)
    HEXDECIMAL      reduce using rule 52 (expr -> literal .)
    CHAR            reduce using rule 52 (expr -> literal .)
    TRUE            reduce using rule 52 (expr -> literal .)
    FALSE           reduce using rule 52 (expr -> literal .)
    SEMI            reduce using rule 52 (expr -> literal .)
    C_PAR           reduce using rule 52 (expr -> literal .)
    C_BRACKET       reduce using rule 52 (expr -> literal .)
    COMMA           reduce using rule 52 (expr -> literal .)
    STRING          reduce using rule 52 (expr -> literal .)


state 77

    (54) expr -> NEGATIVE . expr
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 104
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 78

    (55) expr -> EXCL . expr
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 105
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 79

    (56) expr -> O_PAR . expr C_PAR
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 106
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 80

    (68) literal -> int_literal .

    NEWLINE         reduce using rule 68 (literal -> int_literal .)
    ARITH_OP        reduce using rule 68 (literal -> int_literal .)
    REP_OP          reduce using rule 68 (literal -> int_literal .)
    EQ_OP           reduce using rule 68 (literal -> int_literal .)
    COND_OP         reduce using rule 68 (literal -> int_literal .)
    NEGATIVE        reduce using rule 68 (literal -> int_literal .)
    EXCL            reduce using rule 68 (literal -> int_literal .)
    O_PAR           reduce using rule 68 (literal -> int_literal .)
    IDENTIFIER      reduce using rule 68 (literal -> int_literal .)
    CALLOUT         reduce using rule 68 (literal -> int_literal .)
    DECIMAL         reduce using rule 68 (literal -> int_literal .)
    HEXDECIMAL      reduce using rule 68 (literal -> int_literal .)
    CHAR            reduce using rule 68 (literal -> int_literal .)
    TRUE            reduce using rule 68 (literal -> int_literal .)
    FALSE           reduce using rule 68 (literal -> int_literal .)
    SEMI            reduce using rule 68 (literal -> int_literal .)
    C_PAR           reduce using rule 68 (literal -> int_literal .)
    C_BRACKET       reduce using rule 68 (literal -> int_literal .)
    COMMA           reduce using rule 68 (literal -> int_literal .)
    STRING          reduce using rule 68 (literal -> int_literal .)


state 81

    (69) literal -> char_literal .

    NEWLINE         reduce using rule 69 (literal -> char_literal .)
    ARITH_OP        reduce using rule 69 (literal -> char_literal .)
    REP_OP          reduce using rule 69 (literal -> char_literal .)
    EQ_OP           reduce using rule 69 (literal -> char_literal .)
    COND_OP         reduce using rule 69 (literal -> char_literal .)
    NEGATIVE        reduce using rule 69 (literal -> char_literal .)
    EXCL            reduce using rule 69 (literal -> char_literal .)
    O_PAR           reduce using rule 69 (literal -> char_literal .)
    IDENTIFIER      reduce using rule 69 (literal -> char_literal .)
    CALLOUT         reduce using rule 69 (literal -> char_literal .)
    DECIMAL         reduce using rule 69 (literal -> char_literal .)
    HEXDECIMAL      reduce using rule 69 (literal -> char_literal .)
    CHAR            reduce using rule 69 (literal -> char_literal .)
    TRUE            reduce using rule 69 (literal -> char_literal .)
    FALSE           reduce using rule 69 (literal -> char_literal .)
    SEMI            reduce using rule 69 (literal -> char_literal .)
    C_PAR           reduce using rule 69 (literal -> char_literal .)
    C_BRACKET       reduce using rule 69 (literal -> char_literal .)
    COMMA           reduce using rule 69 (literal -> char_literal .)
    STRING          reduce using rule 69 (literal -> char_literal .)


state 82

    (70) literal -> bool_literal .

    NEWLINE         reduce using rule 70 (literal -> bool_literal .)
    ARITH_OP        reduce using rule 70 (literal -> bool_literal .)
    REP_OP          reduce using rule 70 (literal -> bool_literal .)
    EQ_OP           reduce using rule 70 (literal -> bool_literal .)
    COND_OP         reduce using rule 70 (literal -> bool_literal .)
    NEGATIVE        reduce using rule 70 (literal -> bool_literal .)
    EXCL            reduce using rule 70 (literal -> bool_literal .)
    O_PAR           reduce using rule 70 (literal -> bool_literal .)
    IDENTIFIER      reduce using rule 70 (literal -> bool_literal .)
    CALLOUT         reduce using rule 70 (literal -> bool_literal .)
    DECIMAL         reduce using rule 70 (literal -> bool_literal .)
    HEXDECIMAL      reduce using rule 70 (literal -> bool_literal .)
    CHAR            reduce using rule 70 (literal -> bool_literal .)
    TRUE            reduce using rule 70 (literal -> bool_literal .)
    FALSE           reduce using rule 70 (literal -> bool_literal .)
    SEMI            reduce using rule 70 (literal -> bool_literal .)
    C_PAR           reduce using rule 70 (literal -> bool_literal .)
    C_BRACKET       reduce using rule 70 (literal -> bool_literal .)
    COMMA           reduce using rule 70 (literal -> bool_literal .)
    STRING          reduce using rule 70 (literal -> bool_literal .)


state 83

    (75) char_literal -> CHAR .

    NEWLINE         reduce using rule 75 (char_literal -> CHAR .)
    ARITH_OP        reduce using rule 75 (char_literal -> CHAR .)
    REP_OP          reduce using rule 75 (char_literal -> CHAR .)
    EQ_OP           reduce using rule 75 (char_literal -> CHAR .)
    COND_OP         reduce using rule 75 (char_literal -> CHAR .)
    NEGATIVE        reduce using rule 75 (char_literal -> CHAR .)
    EXCL            reduce using rule 75 (char_literal -> CHAR .)
    O_PAR           reduce using rule 75 (char_literal -> CHAR .)
    IDENTIFIER      reduce using rule 75 (char_literal -> CHAR .)
    CALLOUT         reduce using rule 75 (char_literal -> CHAR .)
    DECIMAL         reduce using rule 75 (char_literal -> CHAR .)
    HEXDECIMAL      reduce using rule 75 (char_literal -> CHAR .)
    CHAR            reduce using rule 75 (char_literal -> CHAR .)
    TRUE            reduce using rule 75 (char_literal -> CHAR .)
    FALSE           reduce using rule 75 (char_literal -> CHAR .)
    SEMI            reduce using rule 75 (char_literal -> CHAR .)
    C_PAR           reduce using rule 75 (char_literal -> CHAR .)
    C_BRACKET       reduce using rule 75 (char_literal -> CHAR .)
    COMMA           reduce using rule 75 (char_literal -> CHAR .)
    STRING          reduce using rule 75 (char_literal -> CHAR .)


state 84

    (73) bool_literal -> TRUE .

    NEWLINE         reduce using rule 73 (bool_literal -> TRUE .)
    ARITH_OP        reduce using rule 73 (bool_literal -> TRUE .)
    REP_OP          reduce using rule 73 (bool_literal -> TRUE .)
    EQ_OP           reduce using rule 73 (bool_literal -> TRUE .)
    COND_OP         reduce using rule 73 (bool_literal -> TRUE .)
    NEGATIVE        reduce using rule 73 (bool_literal -> TRUE .)
    EXCL            reduce using rule 73 (bool_literal -> TRUE .)
    O_PAR           reduce using rule 73 (bool_literal -> TRUE .)
    IDENTIFIER      reduce using rule 73 (bool_literal -> TRUE .)
    CALLOUT         reduce using rule 73 (bool_literal -> TRUE .)
    DECIMAL         reduce using rule 73 (bool_literal -> TRUE .)
    HEXDECIMAL      reduce using rule 73 (bool_literal -> TRUE .)
    CHAR            reduce using rule 73 (bool_literal -> TRUE .)
    TRUE            reduce using rule 73 (bool_literal -> TRUE .)
    FALSE           reduce using rule 73 (bool_literal -> TRUE .)
    SEMI            reduce using rule 73 (bool_literal -> TRUE .)
    C_PAR           reduce using rule 73 (bool_literal -> TRUE .)
    C_BRACKET       reduce using rule 73 (bool_literal -> TRUE .)
    COMMA           reduce using rule 73 (bool_literal -> TRUE .)
    STRING          reduce using rule 73 (bool_literal -> TRUE .)


state 85

    (74) bool_literal -> FALSE .

    NEWLINE         reduce using rule 74 (bool_literal -> FALSE .)
    ARITH_OP        reduce using rule 74 (bool_literal -> FALSE .)
    REP_OP          reduce using rule 74 (bool_literal -> FALSE .)
    EQ_OP           reduce using rule 74 (bool_literal -> FALSE .)
    COND_OP         reduce using rule 74 (bool_literal -> FALSE .)
    NEGATIVE        reduce using rule 74 (bool_literal -> FALSE .)
    EXCL            reduce using rule 74 (bool_literal -> FALSE .)
    O_PAR           reduce using rule 74 (bool_literal -> FALSE .)
    IDENTIFIER      reduce using rule 74 (bool_literal -> FALSE .)
    CALLOUT         reduce using rule 74 (bool_literal -> FALSE .)
    DECIMAL         reduce using rule 74 (bool_literal -> FALSE .)
    HEXDECIMAL      reduce using rule 74 (bool_literal -> FALSE .)
    CHAR            reduce using rule 74 (bool_literal -> FALSE .)
    TRUE            reduce using rule 74 (bool_literal -> FALSE .)
    FALSE           reduce using rule 74 (bool_literal -> FALSE .)
    SEMI            reduce using rule 74 (bool_literal -> FALSE .)
    C_PAR           reduce using rule 74 (bool_literal -> FALSE .)
    C_BRACKET       reduce using rule 74 (bool_literal -> FALSE .)
    COMMA           reduce using rule 74 (bool_literal -> FALSE .)
    STRING          reduce using rule 74 (bool_literal -> FALSE .)


state 86

    (31) statement -> BREAK SEMI .

    CLOSE           reduce using rule 31 (statement -> BREAK SEMI .)
    NEWLINE         reduce using rule 31 (statement -> BREAK SEMI .)
    IF              reduce using rule 31 (statement -> BREAK SEMI .)
    WHILE           reduce using rule 31 (statement -> BREAK SEMI .)
    RETURN          reduce using rule 31 (statement -> BREAK SEMI .)
    BREAK           reduce using rule 31 (statement -> BREAK SEMI .)
    CONTINUE        reduce using rule 31 (statement -> BREAK SEMI .)
    IDENTIFIER      reduce using rule 31 (statement -> BREAK SEMI .)
    CALLOUT         reduce using rule 31 (statement -> BREAK SEMI .)
    OPEN            reduce using rule 31 (statement -> BREAK SEMI .)


state 87

    (32) statement -> CONTINUE SEMI .

    CLOSE           reduce using rule 32 (statement -> CONTINUE SEMI .)
    NEWLINE         reduce using rule 32 (statement -> CONTINUE SEMI .)
    IF              reduce using rule 32 (statement -> CONTINUE SEMI .)
    WHILE           reduce using rule 32 (statement -> CONTINUE SEMI .)
    RETURN          reduce using rule 32 (statement -> CONTINUE SEMI .)
    BREAK           reduce using rule 32 (statement -> CONTINUE SEMI .)
    CONTINUE        reduce using rule 32 (statement -> CONTINUE SEMI .)
    IDENTIFIER      reduce using rule 32 (statement -> CONTINUE SEMI .)
    CALLOUT         reduce using rule 32 (statement -> CONTINUE SEMI .)
    OPEN            reduce using rule 32 (statement -> CONTINUE SEMI .)


state 88

    (49) location -> IDENTIFIER O_BRACKET . expr C_BRACKET
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 107
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 89

    (42) method_call -> method_name O_PAR . arg C_PAR
    (46) arg -> . expr
    (47) arg -> . expr COMMA arg
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    method_name                    shift and go to state 58
    arg                            shift and go to state 108
    expr                           shift and go to state 109
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 90

    (43) method_call -> CALLOUT O_PAR . string_literal C_PAR
    (44) method_call -> CALLOUT O_PAR . string_literal COMMA call COMMA C_PAR
    (76) string_literal -> . STRING

    STRING          shift and go to state 111

    string_literal                 shift and go to state 110

state 91

    (19) var_decl -> type var_decl_1 SEMI .

    IF              reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    WHILE           reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    RETURN          reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    BREAK           reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    CONTINUE        reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    IDENTIFIER      reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    CALLOUT         reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    OPEN            reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    INT             reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    BOOLEAN         reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    CLOSE           reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    NEWLINE         reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)


state 92

    (23) var_decl_1 -> var_decl_1 COMMA . var_decl_1
    (22) var_decl_1 -> . IDENTIFIER
    (23) var_decl_1 -> . var_decl_1 COMMA var_decl_1

    IDENTIFIER      shift and go to state 61

    var_decl_1                     shift and go to state 112

state 93

    (26) statement -> location ASSIGN expr . SEMI
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    SEMI            shift and go to state 113
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    location                       shift and go to state 74
    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 94

    (28) statement -> IF O_PAR expr . C_PAR block NEWLINE else_or_empty
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    C_PAR           shift and go to state 114
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 95

    (29) statement -> WHILE O_PAR expr . C_PAR block
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    C_PAR           shift and go to state 115
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 96

    (30) statement -> RETURN expr_or_empty SEMI .

    CLOSE           reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    NEWLINE         reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    IF              reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    WHILE           reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    RETURN          reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    BREAK           reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    CONTINUE        reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    IDENTIFIER      reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    CALLOUT         reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    OPEN            reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)


state 97

    (57) expr -> expr expr .
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for REP_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for COND_OP resolved as shift
  ! shift/reduce conflict for NEGATIVE resolved as shift
  ! shift/reduce conflict for EXCL resolved as shift
  ! shift/reduce conflict for O_PAR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for HEXDECIMAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    SEMI            reduce using rule 57 (expr -> expr expr .)
    C_PAR           reduce using rule 57 (expr -> expr expr .)
    C_BRACKET       reduce using rule 57 (expr -> expr expr .)
    COMMA           reduce using rule 57 (expr -> expr expr .)
    STRING          reduce using rule 57 (expr -> expr expr .)
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

  ! NEWLINE         [ reduce using rule 57 (expr -> expr expr .) ]
  ! ARITH_OP        [ reduce using rule 57 (expr -> expr expr .) ]
  ! REP_OP          [ reduce using rule 57 (expr -> expr expr .) ]
  ! EQ_OP           [ reduce using rule 57 (expr -> expr expr .) ]
  ! COND_OP         [ reduce using rule 57 (expr -> expr expr .) ]
  ! NEGATIVE        [ reduce using rule 57 (expr -> expr expr .) ]
  ! EXCL            [ reduce using rule 57 (expr -> expr expr .) ]
  ! O_PAR           [ reduce using rule 57 (expr -> expr expr .) ]
  ! IDENTIFIER      [ reduce using rule 57 (expr -> expr expr .) ]
  ! CALLOUT         [ reduce using rule 57 (expr -> expr expr .) ]
  ! DECIMAL         [ reduce using rule 57 (expr -> expr expr .) ]
  ! HEXDECIMAL      [ reduce using rule 57 (expr -> expr expr .) ]
  ! CHAR            [ reduce using rule 57 (expr -> expr expr .) ]
  ! TRUE            [ reduce using rule 57 (expr -> expr expr .) ]
  ! FALSE           [ reduce using rule 57 (expr -> expr expr .) ]

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 98

    (53) expr -> expr bin_op . expr
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 116
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 99

    (58) expr -> expr NEWLINE .

    NEWLINE         reduce using rule 58 (expr -> expr NEWLINE .)
    ARITH_OP        reduce using rule 58 (expr -> expr NEWLINE .)
    REP_OP          reduce using rule 58 (expr -> expr NEWLINE .)
    EQ_OP           reduce using rule 58 (expr -> expr NEWLINE .)
    COND_OP         reduce using rule 58 (expr -> expr NEWLINE .)
    NEGATIVE        reduce using rule 58 (expr -> expr NEWLINE .)
    EXCL            reduce using rule 58 (expr -> expr NEWLINE .)
    O_PAR           reduce using rule 58 (expr -> expr NEWLINE .)
    IDENTIFIER      reduce using rule 58 (expr -> expr NEWLINE .)
    CALLOUT         reduce using rule 58 (expr -> expr NEWLINE .)
    DECIMAL         reduce using rule 58 (expr -> expr NEWLINE .)
    HEXDECIMAL      reduce using rule 58 (expr -> expr NEWLINE .)
    CHAR            reduce using rule 58 (expr -> expr NEWLINE .)
    TRUE            reduce using rule 58 (expr -> expr NEWLINE .)
    FALSE           reduce using rule 58 (expr -> expr NEWLINE .)
    SEMI            reduce using rule 58 (expr -> expr NEWLINE .)
    C_PAR           reduce using rule 58 (expr -> expr NEWLINE .)
    C_BRACKET       reduce using rule 58 (expr -> expr NEWLINE .)
    COMMA           reduce using rule 58 (expr -> expr NEWLINE .)
    STRING          reduce using rule 58 (expr -> expr NEWLINE .)


state 100

    (64) bin_op -> ARITH_OP .

    NEGATIVE        reduce using rule 64 (bin_op -> ARITH_OP .)
    EXCL            reduce using rule 64 (bin_op -> ARITH_OP .)
    O_PAR           reduce using rule 64 (bin_op -> ARITH_OP .)
    IDENTIFIER      reduce using rule 64 (bin_op -> ARITH_OP .)
    CALLOUT         reduce using rule 64 (bin_op -> ARITH_OP .)
    DECIMAL         reduce using rule 64 (bin_op -> ARITH_OP .)
    HEXDECIMAL      reduce using rule 64 (bin_op -> ARITH_OP .)
    CHAR            reduce using rule 64 (bin_op -> ARITH_OP .)
    TRUE            reduce using rule 64 (bin_op -> ARITH_OP .)
    FALSE           reduce using rule 64 (bin_op -> ARITH_OP .)


state 101

    (65) bin_op -> REP_OP .

    NEGATIVE        reduce using rule 65 (bin_op -> REP_OP .)
    EXCL            reduce using rule 65 (bin_op -> REP_OP .)
    O_PAR           reduce using rule 65 (bin_op -> REP_OP .)
    IDENTIFIER      reduce using rule 65 (bin_op -> REP_OP .)
    CALLOUT         reduce using rule 65 (bin_op -> REP_OP .)
    DECIMAL         reduce using rule 65 (bin_op -> REP_OP .)
    HEXDECIMAL      reduce using rule 65 (bin_op -> REP_OP .)
    CHAR            reduce using rule 65 (bin_op -> REP_OP .)
    TRUE            reduce using rule 65 (bin_op -> REP_OP .)
    FALSE           reduce using rule 65 (bin_op -> REP_OP .)


state 102

    (66) bin_op -> EQ_OP .

    NEGATIVE        reduce using rule 66 (bin_op -> EQ_OP .)
    EXCL            reduce using rule 66 (bin_op -> EQ_OP .)
    O_PAR           reduce using rule 66 (bin_op -> EQ_OP .)
    IDENTIFIER      reduce using rule 66 (bin_op -> EQ_OP .)
    CALLOUT         reduce using rule 66 (bin_op -> EQ_OP .)
    DECIMAL         reduce using rule 66 (bin_op -> EQ_OP .)
    HEXDECIMAL      reduce using rule 66 (bin_op -> EQ_OP .)
    CHAR            reduce using rule 66 (bin_op -> EQ_OP .)
    TRUE            reduce using rule 66 (bin_op -> EQ_OP .)
    FALSE           reduce using rule 66 (bin_op -> EQ_OP .)


state 103

    (67) bin_op -> COND_OP .

    NEGATIVE        reduce using rule 67 (bin_op -> COND_OP .)
    EXCL            reduce using rule 67 (bin_op -> COND_OP .)
    O_PAR           reduce using rule 67 (bin_op -> COND_OP .)
    IDENTIFIER      reduce using rule 67 (bin_op -> COND_OP .)
    CALLOUT         reduce using rule 67 (bin_op -> COND_OP .)
    DECIMAL         reduce using rule 67 (bin_op -> COND_OP .)
    HEXDECIMAL      reduce using rule 67 (bin_op -> COND_OP .)
    CHAR            reduce using rule 67 (bin_op -> COND_OP .)
    TRUE            reduce using rule 67 (bin_op -> COND_OP .)
    FALSE           reduce using rule 67 (bin_op -> COND_OP .)


state 104

    (54) expr -> NEGATIVE expr .
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for REP_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for COND_OP resolved as shift
  ! shift/reduce conflict for NEGATIVE resolved as shift
  ! shift/reduce conflict for EXCL resolved as shift
  ! shift/reduce conflict for O_PAR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for HEXDECIMAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    SEMI            reduce using rule 54 (expr -> NEGATIVE expr .)
    C_PAR           reduce using rule 54 (expr -> NEGATIVE expr .)
    C_BRACKET       reduce using rule 54 (expr -> NEGATIVE expr .)
    COMMA           reduce using rule 54 (expr -> NEGATIVE expr .)
    STRING          reduce using rule 54 (expr -> NEGATIVE expr .)
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

  ! NEWLINE         [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! ARITH_OP        [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! REP_OP          [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! EQ_OP           [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! COND_OP         [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! NEGATIVE        [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! EXCL            [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! O_PAR           [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! IDENTIFIER      [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! CALLOUT         [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! DECIMAL         [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! HEXDECIMAL      [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! CHAR            [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! TRUE            [ reduce using rule 54 (expr -> NEGATIVE expr .) ]
  ! FALSE           [ reduce using rule 54 (expr -> NEGATIVE expr .) ]

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 105

    (55) expr -> EXCL expr .
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for REP_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for COND_OP resolved as shift
  ! shift/reduce conflict for NEGATIVE resolved as shift
  ! shift/reduce conflict for EXCL resolved as shift
  ! shift/reduce conflict for O_PAR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for HEXDECIMAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    SEMI            reduce using rule 55 (expr -> EXCL expr .)
    C_PAR           reduce using rule 55 (expr -> EXCL expr .)
    C_BRACKET       reduce using rule 55 (expr -> EXCL expr .)
    COMMA           reduce using rule 55 (expr -> EXCL expr .)
    STRING          reduce using rule 55 (expr -> EXCL expr .)
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

  ! NEWLINE         [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! ARITH_OP        [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! REP_OP          [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! EQ_OP           [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! COND_OP         [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! NEGATIVE        [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! EXCL            [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! O_PAR           [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! IDENTIFIER      [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! CALLOUT         [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! DECIMAL         [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! HEXDECIMAL      [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! CHAR            [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! TRUE            [ reduce using rule 55 (expr -> EXCL expr .) ]
  ! FALSE           [ reduce using rule 55 (expr -> EXCL expr .) ]

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 106

    (56) expr -> O_PAR expr . C_PAR
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    C_PAR           shift and go to state 117
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 107

    (49) location -> IDENTIFIER O_BRACKET expr . C_BRACKET
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    C_BRACKET       shift and go to state 118
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 108

    (42) method_call -> method_name O_PAR arg . C_PAR

    C_PAR           shift and go to state 119


state 109

    (46) arg -> expr .
    (47) arg -> expr . COMMA arg
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    C_PAR           reduce using rule 46 (arg -> expr .)
    COMMA           shift and go to state 120
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 110

    (43) method_call -> CALLOUT O_PAR string_literal . C_PAR
    (44) method_call -> CALLOUT O_PAR string_literal . COMMA call COMMA C_PAR

    C_PAR           shift and go to state 121
    COMMA           shift and go to state 122


state 111

    (76) string_literal -> STRING .

    C_PAR           reduce using rule 76 (string_literal -> STRING .)
    COMMA           reduce using rule 76 (string_literal -> STRING .)
    NEGATIVE        reduce using rule 76 (string_literal -> STRING .)
    EXCL            reduce using rule 76 (string_literal -> STRING .)
    O_PAR           reduce using rule 76 (string_literal -> STRING .)
    STRING          reduce using rule 76 (string_literal -> STRING .)
    IDENTIFIER      reduce using rule 76 (string_literal -> STRING .)
    CALLOUT         reduce using rule 76 (string_literal -> STRING .)
    DECIMAL         reduce using rule 76 (string_literal -> STRING .)
    HEXDECIMAL      reduce using rule 76 (string_literal -> STRING .)
    CHAR            reduce using rule 76 (string_literal -> STRING .)
    TRUE            reduce using rule 76 (string_literal -> STRING .)
    FALSE           reduce using rule 76 (string_literal -> STRING .)


state 112

    (23) var_decl_1 -> var_decl_1 COMMA var_decl_1 .
    (23) var_decl_1 -> var_decl_1 . COMMA var_decl_1

  ! shift/reduce conflict for COMMA resolved as shift
    SEMI            reduce using rule 23 (var_decl_1 -> var_decl_1 COMMA var_decl_1 .)
    COMMA           shift and go to state 92

  ! COMMA           [ reduce using rule 23 (var_decl_1 -> var_decl_1 COMMA var_decl_1 .) ]


state 113

    (26) statement -> location ASSIGN expr SEMI .

    CLOSE           reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    NEWLINE         reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    IF              reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    WHILE           reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    RETURN          reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    BREAK           reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    CONTINUE        reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    IDENTIFIER      reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    CALLOUT         reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    OPEN            reduce using rule 26 (statement -> location ASSIGN expr SEMI .)


state 114

    (28) statement -> IF O_PAR expr C_PAR . block NEWLINE else_or_empty
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 123

state 115

    (29) statement -> WHILE O_PAR expr C_PAR . block
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 124

state 116

    (53) expr -> expr bin_op expr .
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for REP_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for COND_OP resolved as shift
  ! shift/reduce conflict for NEGATIVE resolved as shift
  ! shift/reduce conflict for EXCL resolved as shift
  ! shift/reduce conflict for O_PAR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for HEXDECIMAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    SEMI            reduce using rule 53 (expr -> expr bin_op expr .)
    C_PAR           reduce using rule 53 (expr -> expr bin_op expr .)
    C_BRACKET       reduce using rule 53 (expr -> expr bin_op expr .)
    COMMA           reduce using rule 53 (expr -> expr bin_op expr .)
    STRING          reduce using rule 53 (expr -> expr bin_op expr .)
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

  ! NEWLINE         [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! ARITH_OP        [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! REP_OP          [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! EQ_OP           [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! COND_OP         [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! NEGATIVE        [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! EXCL            [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! O_PAR           [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! IDENTIFIER      [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! CALLOUT         [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! DECIMAL         [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! HEXDECIMAL      [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! CHAR            [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! TRUE            [ reduce using rule 53 (expr -> expr bin_op expr .) ]
  ! FALSE           [ reduce using rule 53 (expr -> expr bin_op expr .) ]

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 117

    (56) expr -> O_PAR expr C_PAR .

    NEWLINE         reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    ARITH_OP        reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    REP_OP          reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    EQ_OP           reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    COND_OP         reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    NEGATIVE        reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    EXCL            reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    O_PAR           reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    IDENTIFIER      reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    CALLOUT         reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    DECIMAL         reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    HEXDECIMAL      reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    CHAR            reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    TRUE            reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    FALSE           reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    SEMI            reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    C_PAR           reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    C_BRACKET       reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    COMMA           reduce using rule 56 (expr -> O_PAR expr C_PAR .)
    STRING          reduce using rule 56 (expr -> O_PAR expr C_PAR .)


state 118

    (49) location -> IDENTIFIER O_BRACKET expr C_BRACKET .

    ASSIGN          reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    NEWLINE         reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    ARITH_OP        reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    REP_OP          reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    EQ_OP           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    COND_OP         reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    NEGATIVE        reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    EXCL            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    O_PAR           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    IDENTIFIER      reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    CALLOUT         reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    DECIMAL         reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    HEXDECIMAL      reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    CHAR            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    TRUE            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    FALSE           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    SEMI            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    C_PAR           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    C_BRACKET       reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    COMMA           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    STRING          reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)


state 119

    (42) method_call -> method_name O_PAR arg C_PAR .

    SEMI            reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    NEWLINE         reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    ARITH_OP        reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    REP_OP          reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    EQ_OP           reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    COND_OP         reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    NEGATIVE        reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    EXCL            reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    O_PAR           reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    IDENTIFIER      reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    CALLOUT         reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    DECIMAL         reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    HEXDECIMAL      reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    CHAR            reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    TRUE            reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    FALSE           reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    C_PAR           reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    C_BRACKET       reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    COMMA           reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)
    STRING          reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)


state 120

    (47) arg -> expr COMMA . arg
    (46) arg -> . expr
    (47) arg -> . expr COMMA arg
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 109
    arg                            shift and go to state 125
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 121

    (43) method_call -> CALLOUT O_PAR string_literal C_PAR .

    SEMI            reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    NEWLINE         reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    ARITH_OP        reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    REP_OP          reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    EQ_OP           reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    COND_OP         reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    NEGATIVE        reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    EXCL            reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    O_PAR           reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    IDENTIFIER      reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    CALLOUT         reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    DECIMAL         reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    HEXDECIMAL      reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    CHAR            reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    TRUE            reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    FALSE           reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    C_PAR           reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    C_BRACKET       reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    COMMA           reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)
    STRING          reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)


state 122

    (44) method_call -> CALLOUT O_PAR string_literal COMMA . call COMMA C_PAR
    (59) call -> . callout_arg
    (60) call -> . callout_arg call
    (61) callout_arg -> . expr
    (62) callout_arg -> . string_literal
    (63) callout_arg -> . callout_arg
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (76) string_literal -> . STRING
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    STRING          shift and go to state 111
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    string_literal                 shift and go to state 126
    call                           shift and go to state 127
    callout_arg                    shift and go to state 128
    expr                           shift and go to state 129
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 123

    (28) statement -> IF O_PAR expr C_PAR block . NEWLINE else_or_empty

    NEWLINE         shift and go to state 130


state 124

    (29) statement -> WHILE O_PAR expr C_PAR block .

    CLOSE           reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    NEWLINE         reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    IF              reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    WHILE           reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    RETURN          reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    BREAK           reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    CONTINUE        reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    IDENTIFIER      reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    CALLOUT         reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    OPEN            reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)


state 125

    (47) arg -> expr COMMA arg .

    C_PAR           reduce using rule 47 (arg -> expr COMMA arg .)


state 126

    (62) callout_arg -> string_literal .

    NEGATIVE        reduce using rule 62 (callout_arg -> string_literal .)
    EXCL            reduce using rule 62 (callout_arg -> string_literal .)
    O_PAR           reduce using rule 62 (callout_arg -> string_literal .)
    STRING          reduce using rule 62 (callout_arg -> string_literal .)
    IDENTIFIER      reduce using rule 62 (callout_arg -> string_literal .)
    CALLOUT         reduce using rule 62 (callout_arg -> string_literal .)
    DECIMAL         reduce using rule 62 (callout_arg -> string_literal .)
    HEXDECIMAL      reduce using rule 62 (callout_arg -> string_literal .)
    CHAR            reduce using rule 62 (callout_arg -> string_literal .)
    TRUE            reduce using rule 62 (callout_arg -> string_literal .)
    FALSE           reduce using rule 62 (callout_arg -> string_literal .)
    COMMA           reduce using rule 62 (callout_arg -> string_literal .)


state 127

    (44) method_call -> CALLOUT O_PAR string_literal COMMA call . COMMA C_PAR

    COMMA           shift and go to state 131


state 128

    (59) call -> callout_arg .
    (60) call -> callout_arg . call
    (63) callout_arg -> callout_arg .
    (59) call -> . callout_arg
    (60) call -> . callout_arg call
    (61) callout_arg -> . expr
    (62) callout_arg -> . string_literal
    (63) callout_arg -> . callout_arg
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (76) string_literal -> . STRING
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

  ! reduce/reduce conflict for COMMA resolved using rule 59 (call -> callout_arg .)
  ! shift/reduce conflict for NEGATIVE resolved as shift
  ! shift/reduce conflict for EXCL resolved as shift
  ! shift/reduce conflict for O_PAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for HEXDECIMAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    COMMA           reduce using rule 59 (call -> callout_arg .)
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    STRING          shift and go to state 111
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

  ! NEGATIVE        [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! EXCL            [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! O_PAR           [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! STRING          [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! IDENTIFIER      [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! CALLOUT         [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! DECIMAL         [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! HEXDECIMAL      [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! CHAR            [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! TRUE            [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! FALSE           [ reduce using rule 63 (callout_arg -> callout_arg .) ]
  ! COMMA           [ reduce using rule 63 (callout_arg -> callout_arg .) ]

    callout_arg                    shift and go to state 128
    call                           shift and go to state 132
    expr                           shift and go to state 129
    string_literal                 shift and go to state 126
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 129

    (61) callout_arg -> expr .
    (53) expr -> expr . bin_op expr
    (57) expr -> expr . expr
    (58) expr -> expr . NEWLINE
    (64) bin_op -> . ARITH_OP
    (65) bin_op -> . REP_OP
    (66) bin_op -> . EQ_OP
    (67) bin_op -> . COND_OP
    (50) expr -> . location
    (51) expr -> . method_call
    (52) expr -> . literal
    (53) expr -> . expr bin_op expr
    (54) expr -> . NEGATIVE expr
    (55) expr -> . EXCL expr
    (56) expr -> . O_PAR expr C_PAR
    (57) expr -> . expr expr
    (58) expr -> . expr NEWLINE
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (68) literal -> . int_literal
    (69) literal -> . char_literal
    (70) literal -> . bool_literal
    (45) method_name -> . IDENTIFIER
    (71) int_literal -> . DECIMAL
    (72) int_literal -> . HEXDECIMAL
    (75) char_literal -> . CHAR
    (73) bool_literal -> . TRUE
    (74) bool_literal -> . FALSE

  ! shift/reduce conflict for NEGATIVE resolved as shift
  ! shift/reduce conflict for EXCL resolved as shift
  ! shift/reduce conflict for O_PAR resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for HEXDECIMAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    STRING          reduce using rule 61 (callout_arg -> expr .)
    COMMA           reduce using rule 61 (callout_arg -> expr .)
    NEWLINE         shift and go to state 99
    ARITH_OP        shift and go to state 100
    REP_OP          shift and go to state 101
    EQ_OP           shift and go to state 102
    COND_OP         shift and go to state 103
    NEGATIVE        shift and go to state 77
    EXCL            shift and go to state 78
    O_PAR           shift and go to state 79
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

  ! NEGATIVE        [ reduce using rule 61 (callout_arg -> expr .) ]
  ! EXCL            [ reduce using rule 61 (callout_arg -> expr .) ]
  ! O_PAR           [ reduce using rule 61 (callout_arg -> expr .) ]
  ! IDENTIFIER      [ reduce using rule 61 (callout_arg -> expr .) ]
  ! CALLOUT         [ reduce using rule 61 (callout_arg -> expr .) ]
  ! DECIMAL         [ reduce using rule 61 (callout_arg -> expr .) ]
  ! HEXDECIMAL      [ reduce using rule 61 (callout_arg -> expr .) ]
  ! CHAR            [ reduce using rule 61 (callout_arg -> expr .) ]
  ! TRUE            [ reduce using rule 61 (callout_arg -> expr .) ]
  ! FALSE           [ reduce using rule 61 (callout_arg -> expr .) ]

    expr                           shift and go to state 97
    bin_op                         shift and go to state 98
    location                       shift and go to state 74
    method_call                    shift and go to state 75
    literal                        shift and go to state 76
    method_name                    shift and go to state 58
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 130

    (28) statement -> IF O_PAR expr C_PAR block NEWLINE . else_or_empty
    (39) else_or_empty -> . ELSE block
    (40) else_or_empty -> . else_or_empty else_or_empty
    (41) else_or_empty -> . empty
    (77) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 134
    CLOSE           reduce using rule 77 (empty -> .)
    NEWLINE         reduce using rule 77 (empty -> .)
    IF              reduce using rule 77 (empty -> .)
    WHILE           reduce using rule 77 (empty -> .)
    RETURN          reduce using rule 77 (empty -> .)
    BREAK           reduce using rule 77 (empty -> .)
    CONTINUE        reduce using rule 77 (empty -> .)
    IDENTIFIER      reduce using rule 77 (empty -> .)
    CALLOUT         reduce using rule 77 (empty -> .)
    OPEN            reduce using rule 77 (empty -> .)

  ! ELSE            [ reduce using rule 77 (empty -> .) ]

    else_or_empty                  shift and go to state 133
    empty                          shift and go to state 135

state 131

    (44) method_call -> CALLOUT O_PAR string_literal COMMA call COMMA . C_PAR

    C_PAR           shift and go to state 136


state 132

    (60) call -> callout_arg call .

    COMMA           reduce using rule 60 (call -> callout_arg call .)


state 133

    (28) statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .
    (40) else_or_empty -> else_or_empty . else_or_empty
    (39) else_or_empty -> . ELSE block
    (40) else_or_empty -> . else_or_empty else_or_empty
    (41) else_or_empty -> . empty
    (77) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for CLOSE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for IF resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for CALLOUT resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for OPEN resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    CLOSE           reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    NEWLINE         reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    IF              reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    WHILE           reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    RETURN          reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    BREAK           reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    CONTINUE        reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    IDENTIFIER      reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    CALLOUT         reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    OPEN            reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    ELSE            shift and go to state 134

  ! ELSE            [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! IF              [ reduce using rule 77 (empty -> .) ]
  ! WHILE           [ reduce using rule 77 (empty -> .) ]
  ! RETURN          [ reduce using rule 77 (empty -> .) ]
  ! BREAK           [ reduce using rule 77 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 77 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 77 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 77 (empty -> .) ]
  ! OPEN            [ reduce using rule 77 (empty -> .) ]

    else_or_empty                  shift and go to state 137
    empty                          shift and go to state 135

state 134

    (39) else_or_empty -> ELSE . block
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 138

state 135

    (41) else_or_empty -> empty .

    ELSE            reduce using rule 41 (else_or_empty -> empty .)
    CLOSE           reduce using rule 41 (else_or_empty -> empty .)
    NEWLINE         reduce using rule 41 (else_or_empty -> empty .)
    IF              reduce using rule 41 (else_or_empty -> empty .)
    WHILE           reduce using rule 41 (else_or_empty -> empty .)
    RETURN          reduce using rule 41 (else_or_empty -> empty .)
    BREAK           reduce using rule 41 (else_or_empty -> empty .)
    CONTINUE        reduce using rule 41 (else_or_empty -> empty .)
    IDENTIFIER      reduce using rule 41 (else_or_empty -> empty .)
    CALLOUT         reduce using rule 41 (else_or_empty -> empty .)
    OPEN            reduce using rule 41 (else_or_empty -> empty .)


state 136

    (44) method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .

    SEMI            reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    NEWLINE         reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    ARITH_OP        reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    REP_OP          reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    EQ_OP           reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    COND_OP         reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    NEGATIVE        reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    EXCL            reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    O_PAR           reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    IDENTIFIER      reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    CALLOUT         reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    DECIMAL         reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    HEXDECIMAL      reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    CHAR            reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    TRUE            reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    FALSE           reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    C_PAR           reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    C_BRACKET       reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    COMMA           reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)
    STRING          reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)


state 137

    (40) else_or_empty -> else_or_empty else_or_empty .
    (40) else_or_empty -> else_or_empty . else_or_empty
    (39) else_or_empty -> . ELSE block
    (40) else_or_empty -> . else_or_empty else_or_empty
    (41) else_or_empty -> . empty
    (77) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for CLOSE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for IF resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for CALLOUT resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for OPEN resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    CLOSE           reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    NEWLINE         reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    IF              reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    WHILE           reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    RETURN          reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    BREAK           reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    CONTINUE        reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    IDENTIFIER      reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    CALLOUT         reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    OPEN            reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    ELSE            shift and go to state 134

  ! ELSE            [ reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .) ]
  ! ELSE            [ reduce using rule 77 (empty -> .) ]
  ! CLOSE           [ reduce using rule 77 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 77 (empty -> .) ]
  ! IF              [ reduce using rule 77 (empty -> .) ]
  ! WHILE           [ reduce using rule 77 (empty -> .) ]
  ! RETURN          [ reduce using rule 77 (empty -> .) ]
  ! BREAK           [ reduce using rule 77 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 77 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 77 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 77 (empty -> .) ]
  ! OPEN            [ reduce using rule 77 (empty -> .) ]

    else_or_empty                  shift and go to state 137
    empty                          shift and go to state 135

state 138

    (39) else_or_empty -> ELSE block .

    ELSE            reduce using rule 39 (else_or_empty -> ELSE block .)
    CLOSE           reduce using rule 39 (else_or_empty -> ELSE block .)
    NEWLINE         reduce using rule 39 (else_or_empty -> ELSE block .)
    IF              reduce using rule 39 (else_or_empty -> ELSE block .)
    WHILE           reduce using rule 39 (else_or_empty -> ELSE block .)
    RETURN          reduce using rule 39 (else_or_empty -> ELSE block .)
    BREAK           reduce using rule 39 (else_or_empty -> ELSE block .)
    CONTINUE        reduce using rule 39 (else_or_empty -> ELSE block .)
    IDENTIFIER      reduce using rule 39 (else_or_empty -> ELSE block .)
    CALLOUT         reduce using rule 39 (else_or_empty -> ELSE block .)
    OPEN            reduce using rule 39 (else_or_empty -> ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for VOID in state 5 resolved as shift
WARNING: shift/reduce conflict for INT in state 5 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 10 resolved as shift
WARNING: shift/reduce conflict for INT in state 10 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 10 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 10 resolved as shift
WARNING: shift/reduce conflict for INT in state 10 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 10 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 11 resolved as shift
WARNING: shift/reduce conflict for VOID in state 11 resolved as shift
WARNING: shift/reduce conflict for CLOSE in state 11 resolved as shift
WARNING: shift/reduce conflict for INT in state 11 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 11 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 19 resolved as shift
WARNING: shift/reduce conflict for VOID in state 19 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 19 resolved as shift
WARNING: shift/reduce conflict for VOID in state 19 resolved as shift
WARNING: shift/reduce conflict for INT in state 19 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 19 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 29 resolved as shift
WARNING: shift/reduce conflict for INT in state 40 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 40 resolved as shift
WARNING: shift/reduce conflict for CLOSE in state 40 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 42 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 42 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 42 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 42 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 42 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 42 resolved as shift
WARNING: shift/reduce conflict for INT in state 42 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 42 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 46 resolved as shift
WARNING: shift/reduce conflict for INT in state 46 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 46 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 47 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 47 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 47 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 47 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 47 resolved as shift
WARNING: shift/reduce conflict for CLOSE in state 47 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 63 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 63 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 63 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 63 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 63 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 63 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 63 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 63 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 63 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 63 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 63 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 63 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 97 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 97 resolved as shift
WARNING: shift/reduce conflict for REP_OP in state 97 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 97 resolved as shift
WARNING: shift/reduce conflict for COND_OP in state 97 resolved as shift
WARNING: shift/reduce conflict for NEGATIVE in state 97 resolved as shift
WARNING: shift/reduce conflict for EXCL in state 97 resolved as shift
WARNING: shift/reduce conflict for O_PAR in state 97 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 97 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 97 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 97 resolved as shift
WARNING: shift/reduce conflict for HEXDECIMAL in state 97 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 97 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 97 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 97 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 104 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 104 resolved as shift
WARNING: shift/reduce conflict for REP_OP in state 104 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 104 resolved as shift
WARNING: shift/reduce conflict for COND_OP in state 104 resolved as shift
WARNING: shift/reduce conflict for NEGATIVE in state 104 resolved as shift
WARNING: shift/reduce conflict for EXCL in state 104 resolved as shift
WARNING: shift/reduce conflict for O_PAR in state 104 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 104 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 104 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 104 resolved as shift
WARNING: shift/reduce conflict for HEXDECIMAL in state 104 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 104 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 104 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 104 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 105 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 105 resolved as shift
WARNING: shift/reduce conflict for REP_OP in state 105 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 105 resolved as shift
WARNING: shift/reduce conflict for COND_OP in state 105 resolved as shift
WARNING: shift/reduce conflict for NEGATIVE in state 105 resolved as shift
WARNING: shift/reduce conflict for EXCL in state 105 resolved as shift
WARNING: shift/reduce conflict for O_PAR in state 105 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 105 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 105 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 105 resolved as shift
WARNING: shift/reduce conflict for HEXDECIMAL in state 105 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 105 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 105 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 105 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 112 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 116 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 116 resolved as shift
WARNING: shift/reduce conflict for REP_OP in state 116 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 116 resolved as shift
WARNING: shift/reduce conflict for COND_OP in state 116 resolved as shift
WARNING: shift/reduce conflict for NEGATIVE in state 116 resolved as shift
WARNING: shift/reduce conflict for EXCL in state 116 resolved as shift
WARNING: shift/reduce conflict for O_PAR in state 116 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 116 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 116 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 116 resolved as shift
WARNING: shift/reduce conflict for HEXDECIMAL in state 116 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 116 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 116 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 116 resolved as shift
WARNING: shift/reduce conflict for NEGATIVE in state 128 resolved as shift
WARNING: shift/reduce conflict for EXCL in state 128 resolved as shift
WARNING: shift/reduce conflict for O_PAR in state 128 resolved as shift
WARNING: shift/reduce conflict for STRING in state 128 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 128 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 128 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 128 resolved as shift
WARNING: shift/reduce conflict for HEXDECIMAL in state 128 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 128 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 128 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 128 resolved as shift
WARNING: shift/reduce conflict for NEGATIVE in state 129 resolved as shift
WARNING: shift/reduce conflict for EXCL in state 129 resolved as shift
WARNING: shift/reduce conflict for O_PAR in state 129 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 129 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 129 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 129 resolved as shift
WARNING: shift/reduce conflict for HEXDECIMAL in state 129 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 129 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 129 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 129 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 130 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 133 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 137 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 137 resolved as shift
WARNING: reduce/reduce conflict in state 10 resolved using rule (field_decl -> field_decl field_decl)
WARNING: rejected rule (empty -> <empty>) in state 10
WARNING: reduce/reduce conflict in state 14 resolved using rule (field_decl -> empty)
WARNING: rejected rule (method_decl -> empty) in state 14
WARNING: reduce/reduce conflict in state 19 resolved using rule (method_decl -> method_decl method_decl)
WARNING: rejected rule (empty -> <empty>) in state 19
WARNING: reduce/reduce conflict in state 56 resolved using rule (var_decl -> empty)
WARNING: rejected rule (statement -> empty) in state 56
WARNING: reduce/reduce conflict in state 57 resolved using rule (method_name -> IDENTIFIER)
WARNING: rejected rule (location -> IDENTIFIER) in state 57
WARNING: reduce/reduce conflict in state 63 resolved using rule (statement -> statement statement)
WARNING: rejected rule (empty -> <empty>) in state 63
WARNING: reduce/reduce conflict in state 128 resolved using rule (call -> callout_arg)
WARNING: rejected rule (callout_arg -> callout_arg) in state 128
WARNING: reduce/reduce conflict in state 133 resolved using rule (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty)
WARNING: rejected rule (empty -> <empty>) in state 133
WARNING: reduce/reduce conflict in state 137 resolved using rule (else_or_empty -> else_or_empty else_or_empty)
WARNING: rejected rule (empty -> <empty>) in state 137
WARNING: Rule (callout_arg -> callout_arg) is never reduced
