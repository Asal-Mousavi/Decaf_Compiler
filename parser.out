Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    KEYWORD
    TAB

Grammar

Rule 0     S' -> program
Rule 1     program -> CLASS PROGRAM OPEN field_decl method_decl CLOSE
Rule 2     field_decl -> type field_decl_1 SEMI
Rule 3     field_decl -> field_decl field_decl
Rule 4     field_decl -> field_decl NEWLINE
Rule 5     field_decl -> empty
Rule 6     field_decl_1 -> IDENTIFIER
Rule 7     field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET
Rule 8     field_decl_1 -> field_decl_1 COMMA field_decl_1
Rule 9     method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
Rule 10    method_decl -> method_decl NEWLINE
Rule 11    method_decl -> method_decl method_decl
Rule 12    method_decl -> empty
Rule 13    type_and_id -> type IDENTIFIER
Rule 14    type_and_id -> type_and_id COMMA type_and_id
Rule 15    type_or_void -> type
Rule 16    type_or_void -> VOID
Rule 17    block -> OPEN var_decl statement CLOSE
Rule 18    block -> OPEN CLOSE
Rule 19    var_decl -> type var_decl_1 SEMI
Rule 20    var_decl -> var_decl var_decl NEWLINE
Rule 21    var_decl -> empty
Rule 22    var_decl_1 -> IDENTIFIER
Rule 23    var_decl_1 -> var_decl_1 COMMA var_decl_1
Rule 24    type -> INT
Rule 25    type -> BOOLEAN
Rule 26    statement -> location ASSIGN expr SEMI
Rule 27    statement -> method_call SEMI
Rule 28    statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty
Rule 29    statement -> WHILE O_PAR expr C_PAR block
Rule 30    statement -> RETURN expr_or_empty SEMI
Rule 31    statement -> BREAK SEMI
Rule 32    statement -> CONTINUE SEMI
Rule 33    statement -> block
Rule 34    statement -> statement statement
Rule 35    statement -> statement NEWLINE
Rule 36    statement -> empty
Rule 37    expr_or_empty -> expr
Rule 38    expr_or_empty -> empty
Rule 39    else_or_empty -> ELSE block
Rule 40    else_or_empty -> else_or_empty else_or_empty
Rule 41    else_or_empty -> empty
Rule 42    method_call -> method_name O_PAR arg C_PAR
Rule 43    method_call -> CALLOUT O_PAR string_literal C_PAR
Rule 44    method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
Rule 45    method_name -> IDENTIFIER
Rule 46    arg -> expr
Rule 47    arg -> expr COMMA arg
Rule 48    location -> IDENTIFIER
Rule 49    location -> IDENTIFIER O_BRACKET expr C_BRACKET
Rule 50    expr -> location
Rule 51    expr -> literal
Rule 52    expr -> expr bin_op expr
Rule 53    expr -> NEGATIVE expr
Rule 54    expr -> EXCL expr
Rule 55    expr -> O_PAR expr C_PAR
Rule 56    call -> callout_arg
Rule 57    call -> callout_arg call
Rule 58    callout_arg -> expr
Rule 59    callout_arg -> string_literal
Rule 60    callout_arg -> callout_arg
Rule 61    bin_op -> ARITH_OP
Rule 62    bin_op -> REP_OP
Rule 63    bin_op -> EQ_OP
Rule 64    bin_op -> COND_OP
Rule 65    literal -> int_literal
Rule 66    literal -> char_literal
Rule 67    literal -> bool_literal
Rule 68    int_literal -> DECIMAL
Rule 69    int_literal -> HEXDECIMAL
Rule 70    bool_literal -> TRUE
Rule 71    bool_literal -> FALSE
Rule 72    char_literal -> CHAR
Rule 73    string_literal -> STRING
Rule 74    empty -> <empty>

Terminals, with rules where they appear

ARITH_OP             : 61
ASSIGN               : 26
BOOLEAN              : 25
BREAK                : 31
CALLOUT              : 43 44
CHAR                 : 72
CLASS                : 1
CLOSE                : 1 17 18
COMMA                : 8 14 23 44 44 47
COMMENT              : 
COND_OP              : 64
CONTINUE             : 32
C_BRACKET            : 7 49
C_PAR                : 9 28 29 42 43 44 55
DECIMAL              : 68
ELSE                 : 39
EQ_OP                : 63
EXCL                 : 54
FALSE                : 71
HEXDECIMAL           : 69
IDENTIFIER           : 6 7 9 13 22 45 48 49
IF                   : 28
INT                  : 24
KEYWORD              : 
NEGATIVE             : 53
NEWLINE              : 4 10 20 28 35
OPEN                 : 1 17 18
O_BRACKET            : 7 49
O_PAR                : 9 28 29 42 43 44 55
PROGRAM              : 1
REP_OP               : 62
RETURN               : 30
SEMI                 : 2 19 26 27 30 31 32
STRING               : 73
TAB                  : 
TRUE                 : 70
VOID                 : 16
WHILE                : 29
error                : 

Nonterminals, with rules where they appear

arg                  : 42 47
bin_op               : 52
block                : 9 28 29 33 39
bool_literal         : 67
call                 : 44 57
callout_arg          : 56 57 60
char_literal         : 66
else_or_empty        : 28 40 40
empty                : 5 12 21 36 38 41
expr                 : 26 28 29 37 46 47 49 52 52 53 54 55 58
expr_or_empty        : 30
field_decl           : 1 3 3 4
field_decl_1         : 2 8 8
int_literal          : 7 65
literal              : 51
location             : 26 50
method_call          : 27
method_decl          : 1 10 11 11
method_name          : 42
program              : 0
statement            : 17 34 34 35
string_literal       : 43 44 59
type                 : 2 13 15 19
type_and_id          : 9 14 14
type_or_void         : 9
var_decl             : 17 20 20
var_decl_1           : 19 23 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . CLASS PROGRAM OPEN field_decl method_decl CLOSE

    CLASS           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> CLASS . PROGRAM OPEN field_decl method_decl CLOSE

    PROGRAM         shift and go to state 3


state 3

    (1) program -> CLASS PROGRAM . OPEN field_decl method_decl CLOSE

    OPEN            shift and go to state 4


state 4

    (1) program -> CLASS PROGRAM OPEN . field_decl method_decl CLOSE
    (2) field_decl -> . type field_decl_1 SEMI
    (3) field_decl -> . field_decl field_decl
    (4) field_decl -> . field_decl NEWLINE
    (5) field_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (74) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9
    NEWLINE         reduce using rule 74 (empty -> .)
    VOID            reduce using rule 74 (empty -> .)
    CLOSE           reduce using rule 74 (empty -> .)

  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]

    field_decl                     shift and go to state 5
    type                           shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> CLASS PROGRAM OPEN field_decl . method_decl CLOSE
    (3) field_decl -> field_decl . field_decl
    (4) field_decl -> field_decl . NEWLINE
    (9) method_decl -> . type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
    (10) method_decl -> . method_decl NEWLINE
    (11) method_decl -> . method_decl method_decl
    (12) method_decl -> . empty
    (2) field_decl -> . type field_decl_1 SEMI
    (3) field_decl -> . field_decl field_decl
    (4) field_decl -> . field_decl NEWLINE
    (5) field_decl -> . empty
    (15) type_or_void -> . type
    (16) type_or_void -> . VOID
    (74) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    NEWLINE         shift and go to state 12
    VOID            shift and go to state 16
    CLOSE           reduce using rule 74 (empty -> .)
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! VOID            [ reduce using rule 74 (empty -> .) ]
  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]

    field_decl                     shift and go to state 10
    method_decl                    shift and go to state 11
    type_or_void                   shift and go to state 13
    empty                          shift and go to state 14
    type                           shift and go to state 15

state 6

    (2) field_decl -> type . field_decl_1 SEMI
    (6) field_decl_1 -> . IDENTIFIER
    (7) field_decl_1 -> . IDENTIFIER O_BRACKET int_literal C_BRACKET
    (8) field_decl_1 -> . field_decl_1 COMMA field_decl_1

    IDENTIFIER      shift and go to state 18

    field_decl_1                   shift and go to state 17

state 7

    (5) field_decl -> empty .

    NEWLINE         reduce using rule 5 (field_decl -> empty .)
    VOID            reduce using rule 5 (field_decl -> empty .)
    INT             reduce using rule 5 (field_decl -> empty .)
    BOOLEAN         reduce using rule 5 (field_decl -> empty .)
    CLOSE           reduce using rule 5 (field_decl -> empty .)


state 8

    (24) type -> INT .

    IDENTIFIER      reduce using rule 24 (type -> INT .)


state 9

    (25) type -> BOOLEAN .

    IDENTIFIER      reduce using rule 25 (type -> BOOLEAN .)


state 10

    (3) field_decl -> field_decl field_decl .
    (3) field_decl -> field_decl . field_decl
    (4) field_decl -> field_decl . NEWLINE
    (2) field_decl -> . type field_decl_1 SEMI
    (3) field_decl -> . field_decl field_decl
    (4) field_decl -> . field_decl NEWLINE
    (5) field_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (74) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 3 (field_decl -> field_decl field_decl .)
  ! reduce/reduce conflict for CLOSE resolved using rule 3 (field_decl -> field_decl field_decl .)
    VOID            reduce using rule 3 (field_decl -> field_decl field_decl .)
    CLOSE           reduce using rule 3 (field_decl -> field_decl field_decl .)
    NEWLINE         shift and go to state 12
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 3 (field_decl -> field_decl field_decl .) ]
  ! INT             [ reduce using rule 3 (field_decl -> field_decl field_decl .) ]
  ! BOOLEAN         [ reduce using rule 3 (field_decl -> field_decl field_decl .) ]
  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]
  ! VOID            [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]

    field_decl                     shift and go to state 10
    type                           shift and go to state 6
    empty                          shift and go to state 7

state 11

    (1) program -> CLASS PROGRAM OPEN field_decl method_decl . CLOSE
    (10) method_decl -> method_decl . NEWLINE
    (11) method_decl -> method_decl . method_decl
    (9) method_decl -> . type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
    (10) method_decl -> . method_decl NEWLINE
    (11) method_decl -> . method_decl method_decl
    (12) method_decl -> . empty
    (15) type_or_void -> . type
    (16) type_or_void -> . VOID
    (74) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for CLOSE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    CLOSE           shift and go to state 20
    NEWLINE         shift and go to state 21
    VOID            shift and go to state 16
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! VOID            [ reduce using rule 74 (empty -> .) ]
  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]

    method_decl                    shift and go to state 19
    type_or_void                   shift and go to state 13
    empty                          shift and go to state 22
    type                           shift and go to state 23

state 12

    (4) field_decl -> field_decl NEWLINE .

    NEWLINE         reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    VOID            reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    INT             reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    BOOLEAN         reduce using rule 4 (field_decl -> field_decl NEWLINE .)
    CLOSE           reduce using rule 4 (field_decl -> field_decl NEWLINE .)


state 13

    (9) method_decl -> type_or_void . IDENTIFIER O_PAR type_and_id C_PAR block

    IDENTIFIER      shift and go to state 24


state 14

    (12) method_decl -> empty .
    (5) field_decl -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for VOID resolved using rule 5 (field_decl -> empty .)
  ! reduce/reduce conflict for CLOSE resolved using rule 5 (field_decl -> empty .)
    NEWLINE         reduce using rule 5 (field_decl -> empty .)
    INT             reduce using rule 5 (field_decl -> empty .)
    BOOLEAN         reduce using rule 5 (field_decl -> empty .)
    VOID            reduce using rule 5 (field_decl -> empty .)
    CLOSE           reduce using rule 5 (field_decl -> empty .)

  ! CLOSE           [ reduce using rule 12 (method_decl -> empty .) ]
  ! NEWLINE         [ reduce using rule 12 (method_decl -> empty .) ]
  ! VOID            [ reduce using rule 12 (method_decl -> empty .) ]
  ! INT             [ reduce using rule 12 (method_decl -> empty .) ]
  ! BOOLEAN         [ reduce using rule 12 (method_decl -> empty .) ]


state 15

    (2) field_decl -> type . field_decl_1 SEMI
    (15) type_or_void -> type .
    (6) field_decl_1 -> . IDENTIFIER
    (7) field_decl_1 -> . IDENTIFIER O_BRACKET int_literal C_BRACKET
    (8) field_decl_1 -> . field_decl_1 COMMA field_decl_1

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 18

  ! IDENTIFIER      [ reduce using rule 15 (type_or_void -> type .) ]

    field_decl_1                   shift and go to state 17

state 16

    (16) type_or_void -> VOID .

    IDENTIFIER      reduce using rule 16 (type_or_void -> VOID .)


state 17

    (2) field_decl -> type field_decl_1 . SEMI
    (8) field_decl_1 -> field_decl_1 . COMMA field_decl_1

    SEMI            shift and go to state 25
    COMMA           shift and go to state 26


state 18

    (6) field_decl_1 -> IDENTIFIER .
    (7) field_decl_1 -> IDENTIFIER . O_BRACKET int_literal C_BRACKET

    SEMI            reduce using rule 6 (field_decl_1 -> IDENTIFIER .)
    COMMA           reduce using rule 6 (field_decl_1 -> IDENTIFIER .)
    O_BRACKET       shift and go to state 27


state 19

    (11) method_decl -> method_decl method_decl .
    (10) method_decl -> method_decl . NEWLINE
    (11) method_decl -> method_decl . method_decl
    (9) method_decl -> . type_or_void IDENTIFIER O_PAR type_and_id C_PAR block
    (10) method_decl -> . method_decl NEWLINE
    (11) method_decl -> . method_decl method_decl
    (12) method_decl -> . empty
    (15) type_or_void -> . type
    (16) type_or_void -> . VOID
    (74) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! reduce/reduce conflict for INT resolved using rule 11 (method_decl -> method_decl method_decl .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 11 (method_decl -> method_decl method_decl .)
  ! reduce/reduce conflict for CLOSE resolved using rule 11 (method_decl -> method_decl method_decl .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    CLOSE           reduce using rule 11 (method_decl -> method_decl method_decl .)
    NEWLINE         shift and go to state 21
    VOID            shift and go to state 16
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! VOID            [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! INT             [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! BOOLEAN         [ reduce using rule 11 (method_decl -> method_decl method_decl .) ]
  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! VOID            [ reduce using rule 74 (empty -> .) ]
  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]

    method_decl                    shift and go to state 19
    type_or_void                   shift and go to state 13
    empty                          shift and go to state 22
    type                           shift and go to state 23

state 20

    (1) program -> CLASS PROGRAM OPEN field_decl method_decl CLOSE .

    $end            reduce using rule 1 (program -> CLASS PROGRAM OPEN field_decl method_decl CLOSE .)


state 21

    (10) method_decl -> method_decl NEWLINE .

    CLOSE           reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    NEWLINE         reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    VOID            reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    INT             reduce using rule 10 (method_decl -> method_decl NEWLINE .)
    BOOLEAN         reduce using rule 10 (method_decl -> method_decl NEWLINE .)


state 22

    (12) method_decl -> empty .

    NEWLINE         reduce using rule 12 (method_decl -> empty .)
    VOID            reduce using rule 12 (method_decl -> empty .)
    INT             reduce using rule 12 (method_decl -> empty .)
    BOOLEAN         reduce using rule 12 (method_decl -> empty .)
    CLOSE           reduce using rule 12 (method_decl -> empty .)


state 23

    (15) type_or_void -> type .

    IDENTIFIER      reduce using rule 15 (type_or_void -> type .)


state 24

    (9) method_decl -> type_or_void IDENTIFIER . O_PAR type_and_id C_PAR block

    O_PAR           shift and go to state 28


state 25

    (2) field_decl -> type field_decl_1 SEMI .

    NEWLINE         reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    VOID            reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    INT             reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    BOOLEAN         reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)
    CLOSE           reduce using rule 2 (field_decl -> type field_decl_1 SEMI .)


state 26

    (8) field_decl_1 -> field_decl_1 COMMA . field_decl_1
    (6) field_decl_1 -> . IDENTIFIER
    (7) field_decl_1 -> . IDENTIFIER O_BRACKET int_literal C_BRACKET
    (8) field_decl_1 -> . field_decl_1 COMMA field_decl_1

    IDENTIFIER      shift and go to state 18

    field_decl_1                   shift and go to state 29

state 27

    (7) field_decl_1 -> IDENTIFIER O_BRACKET . int_literal C_BRACKET
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL

    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32

    int_literal                    shift and go to state 30

state 28

    (9) method_decl -> type_or_void IDENTIFIER O_PAR . type_and_id C_PAR block
    (13) type_and_id -> . type IDENTIFIER
    (14) type_and_id -> . type_and_id COMMA type_and_id
    (24) type -> . INT
    (25) type -> . BOOLEAN

    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

    type_and_id                    shift and go to state 33
    type                           shift and go to state 34

state 29

    (8) field_decl_1 -> field_decl_1 COMMA field_decl_1 .
    (8) field_decl_1 -> field_decl_1 . COMMA field_decl_1

  ! shift/reduce conflict for COMMA resolved as shift
    SEMI            reduce using rule 8 (field_decl_1 -> field_decl_1 COMMA field_decl_1 .)
    COMMA           shift and go to state 26

  ! COMMA           [ reduce using rule 8 (field_decl_1 -> field_decl_1 COMMA field_decl_1 .) ]


state 30

    (7) field_decl_1 -> IDENTIFIER O_BRACKET int_literal . C_BRACKET

    C_BRACKET       shift and go to state 35


state 31

    (68) int_literal -> DECIMAL .

    C_BRACKET       reduce using rule 68 (int_literal -> DECIMAL .)
    ARITH_OP        reduce using rule 68 (int_literal -> DECIMAL .)
    REP_OP          reduce using rule 68 (int_literal -> DECIMAL .)
    EQ_OP           reduce using rule 68 (int_literal -> DECIMAL .)
    COND_OP         reduce using rule 68 (int_literal -> DECIMAL .)
    SEMI            reduce using rule 68 (int_literal -> DECIMAL .)
    C_PAR           reduce using rule 68 (int_literal -> DECIMAL .)
    COMMA           reduce using rule 68 (int_literal -> DECIMAL .)
    NEGATIVE        reduce using rule 68 (int_literal -> DECIMAL .)
    EXCL            reduce using rule 68 (int_literal -> DECIMAL .)
    O_PAR           reduce using rule 68 (int_literal -> DECIMAL .)
    STRING          reduce using rule 68 (int_literal -> DECIMAL .)
    IDENTIFIER      reduce using rule 68 (int_literal -> DECIMAL .)
    DECIMAL         reduce using rule 68 (int_literal -> DECIMAL .)
    HEXDECIMAL      reduce using rule 68 (int_literal -> DECIMAL .)
    CHAR            reduce using rule 68 (int_literal -> DECIMAL .)
    TRUE            reduce using rule 68 (int_literal -> DECIMAL .)
    FALSE           reduce using rule 68 (int_literal -> DECIMAL .)


state 32

    (69) int_literal -> HEXDECIMAL .

    C_BRACKET       reduce using rule 69 (int_literal -> HEXDECIMAL .)
    ARITH_OP        reduce using rule 69 (int_literal -> HEXDECIMAL .)
    REP_OP          reduce using rule 69 (int_literal -> HEXDECIMAL .)
    EQ_OP           reduce using rule 69 (int_literal -> HEXDECIMAL .)
    COND_OP         reduce using rule 69 (int_literal -> HEXDECIMAL .)
    SEMI            reduce using rule 69 (int_literal -> HEXDECIMAL .)
    C_PAR           reduce using rule 69 (int_literal -> HEXDECIMAL .)
    COMMA           reduce using rule 69 (int_literal -> HEXDECIMAL .)
    NEGATIVE        reduce using rule 69 (int_literal -> HEXDECIMAL .)
    EXCL            reduce using rule 69 (int_literal -> HEXDECIMAL .)
    O_PAR           reduce using rule 69 (int_literal -> HEXDECIMAL .)
    STRING          reduce using rule 69 (int_literal -> HEXDECIMAL .)
    IDENTIFIER      reduce using rule 69 (int_literal -> HEXDECIMAL .)
    DECIMAL         reduce using rule 69 (int_literal -> HEXDECIMAL .)
    HEXDECIMAL      reduce using rule 69 (int_literal -> HEXDECIMAL .)
    CHAR            reduce using rule 69 (int_literal -> HEXDECIMAL .)
    TRUE            reduce using rule 69 (int_literal -> HEXDECIMAL .)
    FALSE           reduce using rule 69 (int_literal -> HEXDECIMAL .)


state 33

    (9) method_decl -> type_or_void IDENTIFIER O_PAR type_and_id . C_PAR block
    (14) type_and_id -> type_and_id . COMMA type_and_id

    C_PAR           shift and go to state 36
    COMMA           shift and go to state 37


state 34

    (13) type_and_id -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 38


state 35

    (7) field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET .

    SEMI            reduce using rule 7 (field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET .)
    COMMA           reduce using rule 7 (field_decl_1 -> IDENTIFIER O_BRACKET int_literal C_BRACKET .)


state 36

    (9) method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR . block
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 39

state 37

    (14) type_and_id -> type_and_id COMMA . type_and_id
    (13) type_and_id -> . type IDENTIFIER
    (14) type_and_id -> . type_and_id COMMA type_and_id
    (24) type -> . INT
    (25) type -> . BOOLEAN

    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

    type_and_id                    shift and go to state 41
    type                           shift and go to state 34

state 38

    (13) type_and_id -> type IDENTIFIER .

    C_PAR           reduce using rule 13 (type_and_id -> type IDENTIFIER .)
    COMMA           reduce using rule 13 (type_and_id -> type IDENTIFIER .)


state 39

    (9) method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .

    CLOSE           reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    NEWLINE         reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    VOID            reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    INT             reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)
    BOOLEAN         reduce using rule 9 (method_decl -> type_or_void IDENTIFIER O_PAR type_and_id C_PAR block .)


state 40

    (17) block -> OPEN . var_decl statement CLOSE
    (18) block -> OPEN . CLOSE
    (19) var_decl -> . type var_decl_1 SEMI
    (20) var_decl -> . var_decl var_decl NEWLINE
    (21) var_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (74) empty -> .

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for CLOSE resolved as shift
    CLOSE           shift and go to state 43
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9
    IF              reduce using rule 74 (empty -> .)
    WHILE           reduce using rule 74 (empty -> .)
    RETURN          reduce using rule 74 (empty -> .)
    BREAK           reduce using rule 74 (empty -> .)
    CONTINUE        reduce using rule 74 (empty -> .)
    IDENTIFIER      reduce using rule 74 (empty -> .)
    CALLOUT         reduce using rule 74 (empty -> .)
    OPEN            reduce using rule 74 (empty -> .)
    NEWLINE         reduce using rule 74 (empty -> .)

  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]

    var_decl                       shift and go to state 42
    type                           shift and go to state 44
    empty                          shift and go to state 45

state 41

    (14) type_and_id -> type_and_id COMMA type_and_id .
    (14) type_and_id -> type_and_id . COMMA type_and_id

  ! shift/reduce conflict for COMMA resolved as shift
    C_PAR           reduce using rule 14 (type_and_id -> type_and_id COMMA type_and_id .)
    COMMA           shift and go to state 37

  ! COMMA           [ reduce using rule 14 (type_and_id -> type_and_id COMMA type_and_id .) ]


state 42

    (17) block -> OPEN var_decl . statement CLOSE
    (20) var_decl -> var_decl . var_decl NEWLINE
    (26) statement -> . location ASSIGN expr SEMI
    (27) statement -> . method_call SEMI
    (28) statement -> . IF O_PAR expr C_PAR block NEWLINE else_or_empty
    (29) statement -> . WHILE O_PAR expr C_PAR block
    (30) statement -> . RETURN expr_or_empty SEMI
    (31) statement -> . BREAK SEMI
    (32) statement -> . CONTINUE SEMI
    (33) statement -> . block
    (34) statement -> . statement statement
    (35) statement -> . statement NEWLINE
    (36) statement -> . empty
    (19) var_decl -> . type var_decl_1 SEMI
    (20) var_decl -> . var_decl var_decl NEWLINE
    (21) var_decl -> . empty
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE
    (74) empty -> .
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (45) method_name -> . IDENTIFIER

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    IF              shift and go to state 50
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    BREAK           shift and go to state 54
    CONTINUE        shift and go to state 55
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    OPEN            shift and go to state 40
    CLOSE           reduce using rule 74 (empty -> .)
    NEWLINE         reduce using rule 74 (empty -> .)
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! IF              [ reduce using rule 74 (empty -> .) ]
  ! WHILE           [ reduce using rule 74 (empty -> .) ]
  ! RETURN          [ reduce using rule 74 (empty -> .) ]
  ! BREAK           [ reduce using rule 74 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 74 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 74 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 74 (empty -> .) ]
  ! OPEN            [ reduce using rule 74 (empty -> .) ]
  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]

    var_decl                       shift and go to state 46
    statement                      shift and go to state 47
    location                       shift and go to state 48
    method_call                    shift and go to state 49
    block                          shift and go to state 51
    empty                          shift and go to state 56
    type                           shift and go to state 44
    method_name                    shift and go to state 58

state 43

    (18) block -> OPEN CLOSE .

    CLOSE           reduce using rule 18 (block -> OPEN CLOSE .)
    NEWLINE         reduce using rule 18 (block -> OPEN CLOSE .)
    VOID            reduce using rule 18 (block -> OPEN CLOSE .)
    INT             reduce using rule 18 (block -> OPEN CLOSE .)
    BOOLEAN         reduce using rule 18 (block -> OPEN CLOSE .)
    IF              reduce using rule 18 (block -> OPEN CLOSE .)
    WHILE           reduce using rule 18 (block -> OPEN CLOSE .)
    RETURN          reduce using rule 18 (block -> OPEN CLOSE .)
    BREAK           reduce using rule 18 (block -> OPEN CLOSE .)
    CONTINUE        reduce using rule 18 (block -> OPEN CLOSE .)
    IDENTIFIER      reduce using rule 18 (block -> OPEN CLOSE .)
    CALLOUT         reduce using rule 18 (block -> OPEN CLOSE .)
    OPEN            reduce using rule 18 (block -> OPEN CLOSE .)
    ELSE            reduce using rule 18 (block -> OPEN CLOSE .)


state 44

    (19) var_decl -> type . var_decl_1 SEMI
    (22) var_decl_1 -> . IDENTIFIER
    (23) var_decl_1 -> . var_decl_1 COMMA var_decl_1

    IDENTIFIER      shift and go to state 61

    var_decl_1                     shift and go to state 60

state 45

    (21) var_decl -> empty .

    IF              reduce using rule 21 (var_decl -> empty .)
    WHILE           reduce using rule 21 (var_decl -> empty .)
    RETURN          reduce using rule 21 (var_decl -> empty .)
    BREAK           reduce using rule 21 (var_decl -> empty .)
    CONTINUE        reduce using rule 21 (var_decl -> empty .)
    IDENTIFIER      reduce using rule 21 (var_decl -> empty .)
    CALLOUT         reduce using rule 21 (var_decl -> empty .)
    OPEN            reduce using rule 21 (var_decl -> empty .)
    INT             reduce using rule 21 (var_decl -> empty .)
    BOOLEAN         reduce using rule 21 (var_decl -> empty .)
    CLOSE           reduce using rule 21 (var_decl -> empty .)
    NEWLINE         reduce using rule 21 (var_decl -> empty .)


state 46

    (20) var_decl -> var_decl var_decl . NEWLINE
    (20) var_decl -> var_decl . var_decl NEWLINE
    (19) var_decl -> . type var_decl_1 SEMI
    (20) var_decl -> . var_decl var_decl NEWLINE
    (21) var_decl -> . empty
    (24) type -> . INT
    (25) type -> . BOOLEAN
    (74) empty -> .

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
    NEWLINE         shift and go to state 62
    INT             shift and go to state 8
    BOOLEAN         shift and go to state 9

  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! INT             [ reduce using rule 74 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 74 (empty -> .) ]

    var_decl                       shift and go to state 46
    type                           shift and go to state 44
    empty                          shift and go to state 45

state 47

    (17) block -> OPEN var_decl statement . CLOSE
    (34) statement -> statement . statement
    (35) statement -> statement . NEWLINE
    (26) statement -> . location ASSIGN expr SEMI
    (27) statement -> . method_call SEMI
    (28) statement -> . IF O_PAR expr C_PAR block NEWLINE else_or_empty
    (29) statement -> . WHILE O_PAR expr C_PAR block
    (30) statement -> . RETURN expr_or_empty SEMI
    (31) statement -> . BREAK SEMI
    (32) statement -> . CONTINUE SEMI
    (33) statement -> . block
    (34) statement -> . statement statement
    (35) statement -> . statement NEWLINE
    (36) statement -> . empty
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE
    (74) empty -> .
    (45) method_name -> . IDENTIFIER

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! shift/reduce conflict for CLOSE resolved as shift
    CLOSE           shift and go to state 64
    NEWLINE         shift and go to state 65
    IF              shift and go to state 50
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    BREAK           shift and go to state 54
    CONTINUE        shift and go to state 55
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    OPEN            shift and go to state 40

  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! IF              [ reduce using rule 74 (empty -> .) ]
  ! WHILE           [ reduce using rule 74 (empty -> .) ]
  ! RETURN          [ reduce using rule 74 (empty -> .) ]
  ! BREAK           [ reduce using rule 74 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 74 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 74 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 74 (empty -> .) ]
  ! OPEN            [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]

    statement                      shift and go to state 63
    location                       shift and go to state 48
    method_call                    shift and go to state 49
    block                          shift and go to state 51
    empty                          shift and go to state 66
    method_name                    shift and go to state 58

state 48

    (26) statement -> location . ASSIGN expr SEMI

    ASSIGN          shift and go to state 67


state 49

    (27) statement -> method_call . SEMI

    SEMI            shift and go to state 68


state 50

    (28) statement -> IF . O_PAR expr C_PAR block NEWLINE else_or_empty

    O_PAR           shift and go to state 69


state 51

    (33) statement -> block .

    CLOSE           reduce using rule 33 (statement -> block .)
    NEWLINE         reduce using rule 33 (statement -> block .)
    IF              reduce using rule 33 (statement -> block .)
    WHILE           reduce using rule 33 (statement -> block .)
    RETURN          reduce using rule 33 (statement -> block .)
    BREAK           reduce using rule 33 (statement -> block .)
    CONTINUE        reduce using rule 33 (statement -> block .)
    IDENTIFIER      reduce using rule 33 (statement -> block .)
    CALLOUT         reduce using rule 33 (statement -> block .)
    OPEN            reduce using rule 33 (statement -> block .)


state 52

    (29) statement -> WHILE . O_PAR expr C_PAR block

    O_PAR           shift and go to state 70


state 53

    (30) statement -> RETURN . expr_or_empty SEMI
    (37) expr_or_empty -> . expr
    (38) expr_or_empty -> . empty
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (74) empty -> .
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    SEMI            reduce using rule 74 (empty -> .)
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr_or_empty                  shift and go to state 71
    expr                           shift and go to state 72
    empty                          shift and go to state 73
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 54

    (31) statement -> BREAK . SEMI

    SEMI            shift and go to state 86


state 55

    (32) statement -> CONTINUE . SEMI

    SEMI            shift and go to state 87


state 56

    (36) statement -> empty .
    (21) var_decl -> empty .

  ! reduce/reduce conflict for NEWLINE resolved using rule 21 (var_decl -> empty .)
    CLOSE           reduce using rule 36 (statement -> empty .)
    IF              reduce using rule 36 (statement -> empty .)
    WHILE           reduce using rule 36 (statement -> empty .)
    RETURN          reduce using rule 36 (statement -> empty .)
    BREAK           reduce using rule 36 (statement -> empty .)
    CONTINUE        reduce using rule 36 (statement -> empty .)
    IDENTIFIER      reduce using rule 36 (statement -> empty .)
    CALLOUT         reduce using rule 36 (statement -> empty .)
    OPEN            reduce using rule 36 (statement -> empty .)
    NEWLINE         reduce using rule 21 (var_decl -> empty .)
    INT             reduce using rule 21 (var_decl -> empty .)
    BOOLEAN         reduce using rule 21 (var_decl -> empty .)

  ! NEWLINE         [ reduce using rule 36 (statement -> empty .) ]


state 57

    (48) location -> IDENTIFIER .
    (49) location -> IDENTIFIER . O_BRACKET expr C_BRACKET
    (45) method_name -> IDENTIFIER .

    ASSIGN          reduce using rule 48 (location -> IDENTIFIER .)
    O_BRACKET       shift and go to state 88
    O_PAR           reduce using rule 45 (method_name -> IDENTIFIER .)


state 58

    (42) method_call -> method_name . O_PAR arg C_PAR

    O_PAR           shift and go to state 89


state 59

    (43) method_call -> CALLOUT . O_PAR string_literal C_PAR
    (44) method_call -> CALLOUT . O_PAR string_literal COMMA call COMMA C_PAR

    O_PAR           shift and go to state 90


state 60

    (19) var_decl -> type var_decl_1 . SEMI
    (23) var_decl_1 -> var_decl_1 . COMMA var_decl_1

    SEMI            shift and go to state 91
    COMMA           shift and go to state 92


state 61

    (22) var_decl_1 -> IDENTIFIER .

    SEMI            reduce using rule 22 (var_decl_1 -> IDENTIFIER .)
    COMMA           reduce using rule 22 (var_decl_1 -> IDENTIFIER .)


state 62

    (20) var_decl -> var_decl var_decl NEWLINE .

    IF              reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    WHILE           reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    RETURN          reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    BREAK           reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    CONTINUE        reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    IDENTIFIER      reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    CALLOUT         reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    OPEN            reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    INT             reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    BOOLEAN         reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    CLOSE           reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)
    NEWLINE         reduce using rule 20 (var_decl -> var_decl var_decl NEWLINE .)


state 63

    (34) statement -> statement statement .
    (34) statement -> statement . statement
    (35) statement -> statement . NEWLINE
    (26) statement -> . location ASSIGN expr SEMI
    (27) statement -> . method_call SEMI
    (28) statement -> . IF O_PAR expr C_PAR block NEWLINE else_or_empty
    (29) statement -> . WHILE O_PAR expr C_PAR block
    (30) statement -> . RETURN expr_or_empty SEMI
    (31) statement -> . BREAK SEMI
    (32) statement -> . CONTINUE SEMI
    (33) statement -> . block
    (34) statement -> . statement statement
    (35) statement -> . statement NEWLINE
    (36) statement -> . empty
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (42) method_call -> . method_name O_PAR arg C_PAR
    (43) method_call -> . CALLOUT O_PAR string_literal C_PAR
    (44) method_call -> . CALLOUT O_PAR string_literal COMMA call COMMA C_PAR
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE
    (74) empty -> .
    (45) method_name -> . IDENTIFIER

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for CALLOUT resolved as shift
  ! shift/reduce conflict for OPEN resolved as shift
  ! reduce/reduce conflict for CLOSE resolved using rule 34 (statement -> statement statement .)
    CLOSE           reduce using rule 34 (statement -> statement statement .)
    NEWLINE         shift and go to state 65
    IF              shift and go to state 50
    WHILE           shift and go to state 52
    RETURN          shift and go to state 53
    BREAK           shift and go to state 54
    CONTINUE        shift and go to state 55
    IDENTIFIER      shift and go to state 57
    CALLOUT         shift and go to state 59
    OPEN            shift and go to state 40

  ! NEWLINE         [ reduce using rule 34 (statement -> statement statement .) ]
  ! IF              [ reduce using rule 34 (statement -> statement statement .) ]
  ! WHILE           [ reduce using rule 34 (statement -> statement statement .) ]
  ! RETURN          [ reduce using rule 34 (statement -> statement statement .) ]
  ! BREAK           [ reduce using rule 34 (statement -> statement statement .) ]
  ! CONTINUE        [ reduce using rule 34 (statement -> statement statement .) ]
  ! IDENTIFIER      [ reduce using rule 34 (statement -> statement statement .) ]
  ! CALLOUT         [ reduce using rule 34 (statement -> statement statement .) ]
  ! OPEN            [ reduce using rule 34 (statement -> statement statement .) ]
  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! IF              [ reduce using rule 74 (empty -> .) ]
  ! WHILE           [ reduce using rule 74 (empty -> .) ]
  ! RETURN          [ reduce using rule 74 (empty -> .) ]
  ! BREAK           [ reduce using rule 74 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 74 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 74 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 74 (empty -> .) ]
  ! OPEN            [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]

    statement                      shift and go to state 63
    location                       shift and go to state 48
    method_call                    shift and go to state 49
    block                          shift and go to state 51
    empty                          shift and go to state 66
    method_name                    shift and go to state 58

state 64

    (17) block -> OPEN var_decl statement CLOSE .

    CLOSE           reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    NEWLINE         reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    VOID            reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    INT             reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    BOOLEAN         reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    IF              reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    WHILE           reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    RETURN          reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    BREAK           reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    CONTINUE        reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    IDENTIFIER      reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    CALLOUT         reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    OPEN            reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)
    ELSE            reduce using rule 17 (block -> OPEN var_decl statement CLOSE .)


state 65

    (35) statement -> statement NEWLINE .

    CLOSE           reduce using rule 35 (statement -> statement NEWLINE .)
    NEWLINE         reduce using rule 35 (statement -> statement NEWLINE .)
    IF              reduce using rule 35 (statement -> statement NEWLINE .)
    WHILE           reduce using rule 35 (statement -> statement NEWLINE .)
    RETURN          reduce using rule 35 (statement -> statement NEWLINE .)
    BREAK           reduce using rule 35 (statement -> statement NEWLINE .)
    CONTINUE        reduce using rule 35 (statement -> statement NEWLINE .)
    IDENTIFIER      reduce using rule 35 (statement -> statement NEWLINE .)
    CALLOUT         reduce using rule 35 (statement -> statement NEWLINE .)
    OPEN            reduce using rule 35 (statement -> statement NEWLINE .)


state 66

    (36) statement -> empty .

    NEWLINE         reduce using rule 36 (statement -> empty .)
    IF              reduce using rule 36 (statement -> empty .)
    WHILE           reduce using rule 36 (statement -> empty .)
    RETURN          reduce using rule 36 (statement -> empty .)
    BREAK           reduce using rule 36 (statement -> empty .)
    CONTINUE        reduce using rule 36 (statement -> empty .)
    IDENTIFIER      reduce using rule 36 (statement -> empty .)
    CALLOUT         reduce using rule 36 (statement -> empty .)
    OPEN            reduce using rule 36 (statement -> empty .)
    CLOSE           reduce using rule 36 (statement -> empty .)


state 67

    (26) statement -> location ASSIGN . expr SEMI
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    location                       shift and go to state 74
    expr                           shift and go to state 93
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 68

    (27) statement -> method_call SEMI .

    CLOSE           reduce using rule 27 (statement -> method_call SEMI .)
    NEWLINE         reduce using rule 27 (statement -> method_call SEMI .)
    IF              reduce using rule 27 (statement -> method_call SEMI .)
    WHILE           reduce using rule 27 (statement -> method_call SEMI .)
    RETURN          reduce using rule 27 (statement -> method_call SEMI .)
    BREAK           reduce using rule 27 (statement -> method_call SEMI .)
    CONTINUE        reduce using rule 27 (statement -> method_call SEMI .)
    IDENTIFIER      reduce using rule 27 (statement -> method_call SEMI .)
    CALLOUT         reduce using rule 27 (statement -> method_call SEMI .)
    OPEN            reduce using rule 27 (statement -> method_call SEMI .)


state 69

    (28) statement -> IF O_PAR . expr C_PAR block NEWLINE else_or_empty
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 94
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 70

    (29) statement -> WHILE O_PAR . expr C_PAR block
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 95
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 71

    (30) statement -> RETURN expr_or_empty . SEMI

    SEMI            shift and go to state 96


state 72

    (37) expr_or_empty -> expr .
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    SEMI            reduce using rule 37 (expr_or_empty -> expr .)
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 73

    (38) expr_or_empty -> empty .

    SEMI            reduce using rule 38 (expr_or_empty -> empty .)


state 74

    (50) expr -> location .

    ARITH_OP        reduce using rule 50 (expr -> location .)
    REP_OP          reduce using rule 50 (expr -> location .)
    EQ_OP           reduce using rule 50 (expr -> location .)
    COND_OP         reduce using rule 50 (expr -> location .)
    SEMI            reduce using rule 50 (expr -> location .)
    C_PAR           reduce using rule 50 (expr -> location .)
    C_BRACKET       reduce using rule 50 (expr -> location .)
    COMMA           reduce using rule 50 (expr -> location .)
    NEGATIVE        reduce using rule 50 (expr -> location .)
    EXCL            reduce using rule 50 (expr -> location .)
    O_PAR           reduce using rule 50 (expr -> location .)
    STRING          reduce using rule 50 (expr -> location .)
    IDENTIFIER      reduce using rule 50 (expr -> location .)
    DECIMAL         reduce using rule 50 (expr -> location .)
    HEXDECIMAL      reduce using rule 50 (expr -> location .)
    CHAR            reduce using rule 50 (expr -> location .)
    TRUE            reduce using rule 50 (expr -> location .)
    FALSE           reduce using rule 50 (expr -> location .)


state 75

    (51) expr -> literal .

    ARITH_OP        reduce using rule 51 (expr -> literal .)
    REP_OP          reduce using rule 51 (expr -> literal .)
    EQ_OP           reduce using rule 51 (expr -> literal .)
    COND_OP         reduce using rule 51 (expr -> literal .)
    SEMI            reduce using rule 51 (expr -> literal .)
    C_PAR           reduce using rule 51 (expr -> literal .)
    C_BRACKET       reduce using rule 51 (expr -> literal .)
    COMMA           reduce using rule 51 (expr -> literal .)
    NEGATIVE        reduce using rule 51 (expr -> literal .)
    EXCL            reduce using rule 51 (expr -> literal .)
    O_PAR           reduce using rule 51 (expr -> literal .)
    STRING          reduce using rule 51 (expr -> literal .)
    IDENTIFIER      reduce using rule 51 (expr -> literal .)
    DECIMAL         reduce using rule 51 (expr -> literal .)
    HEXDECIMAL      reduce using rule 51 (expr -> literal .)
    CHAR            reduce using rule 51 (expr -> literal .)
    TRUE            reduce using rule 51 (expr -> literal .)
    FALSE           reduce using rule 51 (expr -> literal .)


state 76

    (53) expr -> NEGATIVE . expr
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 102
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 77

    (54) expr -> EXCL . expr
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 103
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 78

    (55) expr -> O_PAR . expr C_PAR
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 104
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 79

    (48) location -> IDENTIFIER .
    (49) location -> IDENTIFIER . O_BRACKET expr C_BRACKET

    ARITH_OP        reduce using rule 48 (location -> IDENTIFIER .)
    REP_OP          reduce using rule 48 (location -> IDENTIFIER .)
    EQ_OP           reduce using rule 48 (location -> IDENTIFIER .)
    COND_OP         reduce using rule 48 (location -> IDENTIFIER .)
    SEMI            reduce using rule 48 (location -> IDENTIFIER .)
    C_PAR           reduce using rule 48 (location -> IDENTIFIER .)
    C_BRACKET       reduce using rule 48 (location -> IDENTIFIER .)
    COMMA           reduce using rule 48 (location -> IDENTIFIER .)
    NEGATIVE        reduce using rule 48 (location -> IDENTIFIER .)
    EXCL            reduce using rule 48 (location -> IDENTIFIER .)
    O_PAR           reduce using rule 48 (location -> IDENTIFIER .)
    STRING          reduce using rule 48 (location -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 48 (location -> IDENTIFIER .)
    DECIMAL         reduce using rule 48 (location -> IDENTIFIER .)
    HEXDECIMAL      reduce using rule 48 (location -> IDENTIFIER .)
    CHAR            reduce using rule 48 (location -> IDENTIFIER .)
    TRUE            reduce using rule 48 (location -> IDENTIFIER .)
    FALSE           reduce using rule 48 (location -> IDENTIFIER .)
    O_BRACKET       shift and go to state 88


state 80

    (65) literal -> int_literal .

    ARITH_OP        reduce using rule 65 (literal -> int_literal .)
    REP_OP          reduce using rule 65 (literal -> int_literal .)
    EQ_OP           reduce using rule 65 (literal -> int_literal .)
    COND_OP         reduce using rule 65 (literal -> int_literal .)
    SEMI            reduce using rule 65 (literal -> int_literal .)
    C_PAR           reduce using rule 65 (literal -> int_literal .)
    C_BRACKET       reduce using rule 65 (literal -> int_literal .)
    COMMA           reduce using rule 65 (literal -> int_literal .)
    NEGATIVE        reduce using rule 65 (literal -> int_literal .)
    EXCL            reduce using rule 65 (literal -> int_literal .)
    O_PAR           reduce using rule 65 (literal -> int_literal .)
    STRING          reduce using rule 65 (literal -> int_literal .)
    IDENTIFIER      reduce using rule 65 (literal -> int_literal .)
    DECIMAL         reduce using rule 65 (literal -> int_literal .)
    HEXDECIMAL      reduce using rule 65 (literal -> int_literal .)
    CHAR            reduce using rule 65 (literal -> int_literal .)
    TRUE            reduce using rule 65 (literal -> int_literal .)
    FALSE           reduce using rule 65 (literal -> int_literal .)


state 81

    (66) literal -> char_literal .

    ARITH_OP        reduce using rule 66 (literal -> char_literal .)
    REP_OP          reduce using rule 66 (literal -> char_literal .)
    EQ_OP           reduce using rule 66 (literal -> char_literal .)
    COND_OP         reduce using rule 66 (literal -> char_literal .)
    SEMI            reduce using rule 66 (literal -> char_literal .)
    C_PAR           reduce using rule 66 (literal -> char_literal .)
    C_BRACKET       reduce using rule 66 (literal -> char_literal .)
    COMMA           reduce using rule 66 (literal -> char_literal .)
    NEGATIVE        reduce using rule 66 (literal -> char_literal .)
    EXCL            reduce using rule 66 (literal -> char_literal .)
    O_PAR           reduce using rule 66 (literal -> char_literal .)
    STRING          reduce using rule 66 (literal -> char_literal .)
    IDENTIFIER      reduce using rule 66 (literal -> char_literal .)
    DECIMAL         reduce using rule 66 (literal -> char_literal .)
    HEXDECIMAL      reduce using rule 66 (literal -> char_literal .)
    CHAR            reduce using rule 66 (literal -> char_literal .)
    TRUE            reduce using rule 66 (literal -> char_literal .)
    FALSE           reduce using rule 66 (literal -> char_literal .)


state 82

    (67) literal -> bool_literal .

    ARITH_OP        reduce using rule 67 (literal -> bool_literal .)
    REP_OP          reduce using rule 67 (literal -> bool_literal .)
    EQ_OP           reduce using rule 67 (literal -> bool_literal .)
    COND_OP         reduce using rule 67 (literal -> bool_literal .)
    SEMI            reduce using rule 67 (literal -> bool_literal .)
    C_PAR           reduce using rule 67 (literal -> bool_literal .)
    C_BRACKET       reduce using rule 67 (literal -> bool_literal .)
    COMMA           reduce using rule 67 (literal -> bool_literal .)
    NEGATIVE        reduce using rule 67 (literal -> bool_literal .)
    EXCL            reduce using rule 67 (literal -> bool_literal .)
    O_PAR           reduce using rule 67 (literal -> bool_literal .)
    STRING          reduce using rule 67 (literal -> bool_literal .)
    IDENTIFIER      reduce using rule 67 (literal -> bool_literal .)
    DECIMAL         reduce using rule 67 (literal -> bool_literal .)
    HEXDECIMAL      reduce using rule 67 (literal -> bool_literal .)
    CHAR            reduce using rule 67 (literal -> bool_literal .)
    TRUE            reduce using rule 67 (literal -> bool_literal .)
    FALSE           reduce using rule 67 (literal -> bool_literal .)


state 83

    (72) char_literal -> CHAR .

    ARITH_OP        reduce using rule 72 (char_literal -> CHAR .)
    REP_OP          reduce using rule 72 (char_literal -> CHAR .)
    EQ_OP           reduce using rule 72 (char_literal -> CHAR .)
    COND_OP         reduce using rule 72 (char_literal -> CHAR .)
    SEMI            reduce using rule 72 (char_literal -> CHAR .)
    C_PAR           reduce using rule 72 (char_literal -> CHAR .)
    C_BRACKET       reduce using rule 72 (char_literal -> CHAR .)
    COMMA           reduce using rule 72 (char_literal -> CHAR .)
    NEGATIVE        reduce using rule 72 (char_literal -> CHAR .)
    EXCL            reduce using rule 72 (char_literal -> CHAR .)
    O_PAR           reduce using rule 72 (char_literal -> CHAR .)
    STRING          reduce using rule 72 (char_literal -> CHAR .)
    IDENTIFIER      reduce using rule 72 (char_literal -> CHAR .)
    DECIMAL         reduce using rule 72 (char_literal -> CHAR .)
    HEXDECIMAL      reduce using rule 72 (char_literal -> CHAR .)
    CHAR            reduce using rule 72 (char_literal -> CHAR .)
    TRUE            reduce using rule 72 (char_literal -> CHAR .)
    FALSE           reduce using rule 72 (char_literal -> CHAR .)


state 84

    (70) bool_literal -> TRUE .

    ARITH_OP        reduce using rule 70 (bool_literal -> TRUE .)
    REP_OP          reduce using rule 70 (bool_literal -> TRUE .)
    EQ_OP           reduce using rule 70 (bool_literal -> TRUE .)
    COND_OP         reduce using rule 70 (bool_literal -> TRUE .)
    SEMI            reduce using rule 70 (bool_literal -> TRUE .)
    C_PAR           reduce using rule 70 (bool_literal -> TRUE .)
    C_BRACKET       reduce using rule 70 (bool_literal -> TRUE .)
    COMMA           reduce using rule 70 (bool_literal -> TRUE .)
    NEGATIVE        reduce using rule 70 (bool_literal -> TRUE .)
    EXCL            reduce using rule 70 (bool_literal -> TRUE .)
    O_PAR           reduce using rule 70 (bool_literal -> TRUE .)
    STRING          reduce using rule 70 (bool_literal -> TRUE .)
    IDENTIFIER      reduce using rule 70 (bool_literal -> TRUE .)
    DECIMAL         reduce using rule 70 (bool_literal -> TRUE .)
    HEXDECIMAL      reduce using rule 70 (bool_literal -> TRUE .)
    CHAR            reduce using rule 70 (bool_literal -> TRUE .)
    TRUE            reduce using rule 70 (bool_literal -> TRUE .)
    FALSE           reduce using rule 70 (bool_literal -> TRUE .)


state 85

    (71) bool_literal -> FALSE .

    ARITH_OP        reduce using rule 71 (bool_literal -> FALSE .)
    REP_OP          reduce using rule 71 (bool_literal -> FALSE .)
    EQ_OP           reduce using rule 71 (bool_literal -> FALSE .)
    COND_OP         reduce using rule 71 (bool_literal -> FALSE .)
    SEMI            reduce using rule 71 (bool_literal -> FALSE .)
    C_PAR           reduce using rule 71 (bool_literal -> FALSE .)
    C_BRACKET       reduce using rule 71 (bool_literal -> FALSE .)
    COMMA           reduce using rule 71 (bool_literal -> FALSE .)
    NEGATIVE        reduce using rule 71 (bool_literal -> FALSE .)
    EXCL            reduce using rule 71 (bool_literal -> FALSE .)
    O_PAR           reduce using rule 71 (bool_literal -> FALSE .)
    STRING          reduce using rule 71 (bool_literal -> FALSE .)
    IDENTIFIER      reduce using rule 71 (bool_literal -> FALSE .)
    DECIMAL         reduce using rule 71 (bool_literal -> FALSE .)
    HEXDECIMAL      reduce using rule 71 (bool_literal -> FALSE .)
    CHAR            reduce using rule 71 (bool_literal -> FALSE .)
    TRUE            reduce using rule 71 (bool_literal -> FALSE .)
    FALSE           reduce using rule 71 (bool_literal -> FALSE .)


state 86

    (31) statement -> BREAK SEMI .

    CLOSE           reduce using rule 31 (statement -> BREAK SEMI .)
    NEWLINE         reduce using rule 31 (statement -> BREAK SEMI .)
    IF              reduce using rule 31 (statement -> BREAK SEMI .)
    WHILE           reduce using rule 31 (statement -> BREAK SEMI .)
    RETURN          reduce using rule 31 (statement -> BREAK SEMI .)
    BREAK           reduce using rule 31 (statement -> BREAK SEMI .)
    CONTINUE        reduce using rule 31 (statement -> BREAK SEMI .)
    IDENTIFIER      reduce using rule 31 (statement -> BREAK SEMI .)
    CALLOUT         reduce using rule 31 (statement -> BREAK SEMI .)
    OPEN            reduce using rule 31 (statement -> BREAK SEMI .)


state 87

    (32) statement -> CONTINUE SEMI .

    CLOSE           reduce using rule 32 (statement -> CONTINUE SEMI .)
    NEWLINE         reduce using rule 32 (statement -> CONTINUE SEMI .)
    IF              reduce using rule 32 (statement -> CONTINUE SEMI .)
    WHILE           reduce using rule 32 (statement -> CONTINUE SEMI .)
    RETURN          reduce using rule 32 (statement -> CONTINUE SEMI .)
    BREAK           reduce using rule 32 (statement -> CONTINUE SEMI .)
    CONTINUE        reduce using rule 32 (statement -> CONTINUE SEMI .)
    IDENTIFIER      reduce using rule 32 (statement -> CONTINUE SEMI .)
    CALLOUT         reduce using rule 32 (statement -> CONTINUE SEMI .)
    OPEN            reduce using rule 32 (statement -> CONTINUE SEMI .)


state 88

    (49) location -> IDENTIFIER O_BRACKET . expr C_BRACKET
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 105
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 89

    (42) method_call -> method_name O_PAR . arg C_PAR
    (46) arg -> . expr
    (47) arg -> . expr COMMA arg
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    arg                            shift and go to state 106
    expr                           shift and go to state 107
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 90

    (43) method_call -> CALLOUT O_PAR . string_literal C_PAR
    (44) method_call -> CALLOUT O_PAR . string_literal COMMA call COMMA C_PAR
    (73) string_literal -> . STRING

    STRING          shift and go to state 109

    string_literal                 shift and go to state 108

state 91

    (19) var_decl -> type var_decl_1 SEMI .

    IF              reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    WHILE           reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    RETURN          reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    BREAK           reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    CONTINUE        reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    IDENTIFIER      reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    CALLOUT         reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    OPEN            reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    INT             reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    BOOLEAN         reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    CLOSE           reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)
    NEWLINE         reduce using rule 19 (var_decl -> type var_decl_1 SEMI .)


state 92

    (23) var_decl_1 -> var_decl_1 COMMA . var_decl_1
    (22) var_decl_1 -> . IDENTIFIER
    (23) var_decl_1 -> . var_decl_1 COMMA var_decl_1

    IDENTIFIER      shift and go to state 61

    var_decl_1                     shift and go to state 110

state 93

    (26) statement -> location ASSIGN expr . SEMI
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    SEMI            shift and go to state 111
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 94

    (28) statement -> IF O_PAR expr . C_PAR block NEWLINE else_or_empty
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    C_PAR           shift and go to state 112
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 95

    (29) statement -> WHILE O_PAR expr . C_PAR block
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    C_PAR           shift and go to state 113
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 96

    (30) statement -> RETURN expr_or_empty SEMI .

    CLOSE           reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    NEWLINE         reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    IF              reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    WHILE           reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    RETURN          reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    BREAK           reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    CONTINUE        reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    IDENTIFIER      reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    CALLOUT         reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)
    OPEN            reduce using rule 30 (statement -> RETURN expr_or_empty SEMI .)


state 97

    (52) expr -> expr bin_op . expr
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 114
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 98

    (61) bin_op -> ARITH_OP .

    NEGATIVE        reduce using rule 61 (bin_op -> ARITH_OP .)
    EXCL            reduce using rule 61 (bin_op -> ARITH_OP .)
    O_PAR           reduce using rule 61 (bin_op -> ARITH_OP .)
    IDENTIFIER      reduce using rule 61 (bin_op -> ARITH_OP .)
    DECIMAL         reduce using rule 61 (bin_op -> ARITH_OP .)
    HEXDECIMAL      reduce using rule 61 (bin_op -> ARITH_OP .)
    CHAR            reduce using rule 61 (bin_op -> ARITH_OP .)
    TRUE            reduce using rule 61 (bin_op -> ARITH_OP .)
    FALSE           reduce using rule 61 (bin_op -> ARITH_OP .)


state 99

    (62) bin_op -> REP_OP .

    NEGATIVE        reduce using rule 62 (bin_op -> REP_OP .)
    EXCL            reduce using rule 62 (bin_op -> REP_OP .)
    O_PAR           reduce using rule 62 (bin_op -> REP_OP .)
    IDENTIFIER      reduce using rule 62 (bin_op -> REP_OP .)
    DECIMAL         reduce using rule 62 (bin_op -> REP_OP .)
    HEXDECIMAL      reduce using rule 62 (bin_op -> REP_OP .)
    CHAR            reduce using rule 62 (bin_op -> REP_OP .)
    TRUE            reduce using rule 62 (bin_op -> REP_OP .)
    FALSE           reduce using rule 62 (bin_op -> REP_OP .)


state 100

    (63) bin_op -> EQ_OP .

    NEGATIVE        reduce using rule 63 (bin_op -> EQ_OP .)
    EXCL            reduce using rule 63 (bin_op -> EQ_OP .)
    O_PAR           reduce using rule 63 (bin_op -> EQ_OP .)
    IDENTIFIER      reduce using rule 63 (bin_op -> EQ_OP .)
    DECIMAL         reduce using rule 63 (bin_op -> EQ_OP .)
    HEXDECIMAL      reduce using rule 63 (bin_op -> EQ_OP .)
    CHAR            reduce using rule 63 (bin_op -> EQ_OP .)
    TRUE            reduce using rule 63 (bin_op -> EQ_OP .)
    FALSE           reduce using rule 63 (bin_op -> EQ_OP .)


state 101

    (64) bin_op -> COND_OP .

    NEGATIVE        reduce using rule 64 (bin_op -> COND_OP .)
    EXCL            reduce using rule 64 (bin_op -> COND_OP .)
    O_PAR           reduce using rule 64 (bin_op -> COND_OP .)
    IDENTIFIER      reduce using rule 64 (bin_op -> COND_OP .)
    DECIMAL         reduce using rule 64 (bin_op -> COND_OP .)
    HEXDECIMAL      reduce using rule 64 (bin_op -> COND_OP .)
    CHAR            reduce using rule 64 (bin_op -> COND_OP .)
    TRUE            reduce using rule 64 (bin_op -> COND_OP .)
    FALSE           reduce using rule 64 (bin_op -> COND_OP .)


state 102

    (53) expr -> NEGATIVE expr .
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for REP_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for COND_OP resolved as shift
    SEMI            reduce using rule 53 (expr -> NEGATIVE expr .)
    C_PAR           reduce using rule 53 (expr -> NEGATIVE expr .)
    C_BRACKET       reduce using rule 53 (expr -> NEGATIVE expr .)
    COMMA           reduce using rule 53 (expr -> NEGATIVE expr .)
    NEGATIVE        reduce using rule 53 (expr -> NEGATIVE expr .)
    EXCL            reduce using rule 53 (expr -> NEGATIVE expr .)
    O_PAR           reduce using rule 53 (expr -> NEGATIVE expr .)
    STRING          reduce using rule 53 (expr -> NEGATIVE expr .)
    IDENTIFIER      reduce using rule 53 (expr -> NEGATIVE expr .)
    DECIMAL         reduce using rule 53 (expr -> NEGATIVE expr .)
    HEXDECIMAL      reduce using rule 53 (expr -> NEGATIVE expr .)
    CHAR            reduce using rule 53 (expr -> NEGATIVE expr .)
    TRUE            reduce using rule 53 (expr -> NEGATIVE expr .)
    FALSE           reduce using rule 53 (expr -> NEGATIVE expr .)
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

  ! ARITH_OP        [ reduce using rule 53 (expr -> NEGATIVE expr .) ]
  ! REP_OP          [ reduce using rule 53 (expr -> NEGATIVE expr .) ]
  ! EQ_OP           [ reduce using rule 53 (expr -> NEGATIVE expr .) ]
  ! COND_OP         [ reduce using rule 53 (expr -> NEGATIVE expr .) ]

    bin_op                         shift and go to state 97

state 103

    (54) expr -> EXCL expr .
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for REP_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for COND_OP resolved as shift
    SEMI            reduce using rule 54 (expr -> EXCL expr .)
    C_PAR           reduce using rule 54 (expr -> EXCL expr .)
    C_BRACKET       reduce using rule 54 (expr -> EXCL expr .)
    COMMA           reduce using rule 54 (expr -> EXCL expr .)
    NEGATIVE        reduce using rule 54 (expr -> EXCL expr .)
    EXCL            reduce using rule 54 (expr -> EXCL expr .)
    O_PAR           reduce using rule 54 (expr -> EXCL expr .)
    STRING          reduce using rule 54 (expr -> EXCL expr .)
    IDENTIFIER      reduce using rule 54 (expr -> EXCL expr .)
    DECIMAL         reduce using rule 54 (expr -> EXCL expr .)
    HEXDECIMAL      reduce using rule 54 (expr -> EXCL expr .)
    CHAR            reduce using rule 54 (expr -> EXCL expr .)
    TRUE            reduce using rule 54 (expr -> EXCL expr .)
    FALSE           reduce using rule 54 (expr -> EXCL expr .)
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

  ! ARITH_OP        [ reduce using rule 54 (expr -> EXCL expr .) ]
  ! REP_OP          [ reduce using rule 54 (expr -> EXCL expr .) ]
  ! EQ_OP           [ reduce using rule 54 (expr -> EXCL expr .) ]
  ! COND_OP         [ reduce using rule 54 (expr -> EXCL expr .) ]

    bin_op                         shift and go to state 97

state 104

    (55) expr -> O_PAR expr . C_PAR
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    C_PAR           shift and go to state 115
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 105

    (49) location -> IDENTIFIER O_BRACKET expr . C_BRACKET
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    C_BRACKET       shift and go to state 116
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 106

    (42) method_call -> method_name O_PAR arg . C_PAR

    C_PAR           shift and go to state 117


state 107

    (46) arg -> expr .
    (47) arg -> expr . COMMA arg
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    C_PAR           reduce using rule 46 (arg -> expr .)
    COMMA           shift and go to state 118
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 108

    (43) method_call -> CALLOUT O_PAR string_literal . C_PAR
    (44) method_call -> CALLOUT O_PAR string_literal . COMMA call COMMA C_PAR

    C_PAR           shift and go to state 119
    COMMA           shift and go to state 120


state 109

    (73) string_literal -> STRING .

    C_PAR           reduce using rule 73 (string_literal -> STRING .)
    COMMA           reduce using rule 73 (string_literal -> STRING .)
    NEGATIVE        reduce using rule 73 (string_literal -> STRING .)
    EXCL            reduce using rule 73 (string_literal -> STRING .)
    O_PAR           reduce using rule 73 (string_literal -> STRING .)
    STRING          reduce using rule 73 (string_literal -> STRING .)
    IDENTIFIER      reduce using rule 73 (string_literal -> STRING .)
    DECIMAL         reduce using rule 73 (string_literal -> STRING .)
    HEXDECIMAL      reduce using rule 73 (string_literal -> STRING .)
    CHAR            reduce using rule 73 (string_literal -> STRING .)
    TRUE            reduce using rule 73 (string_literal -> STRING .)
    FALSE           reduce using rule 73 (string_literal -> STRING .)


state 110

    (23) var_decl_1 -> var_decl_1 COMMA var_decl_1 .
    (23) var_decl_1 -> var_decl_1 . COMMA var_decl_1

  ! shift/reduce conflict for COMMA resolved as shift
    SEMI            reduce using rule 23 (var_decl_1 -> var_decl_1 COMMA var_decl_1 .)
    COMMA           shift and go to state 92

  ! COMMA           [ reduce using rule 23 (var_decl_1 -> var_decl_1 COMMA var_decl_1 .) ]


state 111

    (26) statement -> location ASSIGN expr SEMI .

    CLOSE           reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    NEWLINE         reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    IF              reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    WHILE           reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    RETURN          reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    BREAK           reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    CONTINUE        reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    IDENTIFIER      reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    CALLOUT         reduce using rule 26 (statement -> location ASSIGN expr SEMI .)
    OPEN            reduce using rule 26 (statement -> location ASSIGN expr SEMI .)


state 112

    (28) statement -> IF O_PAR expr C_PAR . block NEWLINE else_or_empty
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 121

state 113

    (29) statement -> WHILE O_PAR expr C_PAR . block
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 122

state 114

    (52) expr -> expr bin_op expr .
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

  ! shift/reduce conflict for ARITH_OP resolved as shift
  ! shift/reduce conflict for REP_OP resolved as shift
  ! shift/reduce conflict for EQ_OP resolved as shift
  ! shift/reduce conflict for COND_OP resolved as shift
    SEMI            reduce using rule 52 (expr -> expr bin_op expr .)
    C_PAR           reduce using rule 52 (expr -> expr bin_op expr .)
    C_BRACKET       reduce using rule 52 (expr -> expr bin_op expr .)
    COMMA           reduce using rule 52 (expr -> expr bin_op expr .)
    NEGATIVE        reduce using rule 52 (expr -> expr bin_op expr .)
    EXCL            reduce using rule 52 (expr -> expr bin_op expr .)
    O_PAR           reduce using rule 52 (expr -> expr bin_op expr .)
    STRING          reduce using rule 52 (expr -> expr bin_op expr .)
    IDENTIFIER      reduce using rule 52 (expr -> expr bin_op expr .)
    DECIMAL         reduce using rule 52 (expr -> expr bin_op expr .)
    HEXDECIMAL      reduce using rule 52 (expr -> expr bin_op expr .)
    CHAR            reduce using rule 52 (expr -> expr bin_op expr .)
    TRUE            reduce using rule 52 (expr -> expr bin_op expr .)
    FALSE           reduce using rule 52 (expr -> expr bin_op expr .)
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

  ! ARITH_OP        [ reduce using rule 52 (expr -> expr bin_op expr .) ]
  ! REP_OP          [ reduce using rule 52 (expr -> expr bin_op expr .) ]
  ! EQ_OP           [ reduce using rule 52 (expr -> expr bin_op expr .) ]
  ! COND_OP         [ reduce using rule 52 (expr -> expr bin_op expr .) ]

    bin_op                         shift and go to state 97

state 115

    (55) expr -> O_PAR expr C_PAR .

    ARITH_OP        reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    REP_OP          reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    EQ_OP           reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    COND_OP         reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    SEMI            reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    C_PAR           reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    C_BRACKET       reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    COMMA           reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    NEGATIVE        reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    EXCL            reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    O_PAR           reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    STRING          reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    IDENTIFIER      reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    DECIMAL         reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    HEXDECIMAL      reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    CHAR            reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    TRUE            reduce using rule 55 (expr -> O_PAR expr C_PAR .)
    FALSE           reduce using rule 55 (expr -> O_PAR expr C_PAR .)


state 116

    (49) location -> IDENTIFIER O_BRACKET expr C_BRACKET .

    ASSIGN          reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    ARITH_OP        reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    REP_OP          reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    EQ_OP           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    COND_OP         reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    SEMI            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    C_PAR           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    C_BRACKET       reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    COMMA           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    NEGATIVE        reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    EXCL            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    O_PAR           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    STRING          reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    IDENTIFIER      reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    DECIMAL         reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    HEXDECIMAL      reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    CHAR            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    TRUE            reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)
    FALSE           reduce using rule 49 (location -> IDENTIFIER O_BRACKET expr C_BRACKET .)


state 117

    (42) method_call -> method_name O_PAR arg C_PAR .

    SEMI            reduce using rule 42 (method_call -> method_name O_PAR arg C_PAR .)


state 118

    (47) arg -> expr COMMA . arg
    (46) arg -> . expr
    (47) arg -> . expr COMMA arg
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    expr                           shift and go to state 107
    arg                            shift and go to state 123
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 119

    (43) method_call -> CALLOUT O_PAR string_literal C_PAR .

    SEMI            reduce using rule 43 (method_call -> CALLOUT O_PAR string_literal C_PAR .)


state 120

    (44) method_call -> CALLOUT O_PAR string_literal COMMA . call COMMA C_PAR
    (56) call -> . callout_arg
    (57) call -> . callout_arg call
    (58) callout_arg -> . expr
    (59) callout_arg -> . string_literal
    (60) callout_arg -> . callout_arg
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (73) string_literal -> . STRING
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    STRING          shift and go to state 109
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

    string_literal                 shift and go to state 124
    call                           shift and go to state 125
    callout_arg                    shift and go to state 126
    expr                           shift and go to state 127
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 121

    (28) statement -> IF O_PAR expr C_PAR block . NEWLINE else_or_empty

    NEWLINE         shift and go to state 128


state 122

    (29) statement -> WHILE O_PAR expr C_PAR block .

    CLOSE           reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    NEWLINE         reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    IF              reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    WHILE           reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    RETURN          reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    BREAK           reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    CONTINUE        reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    IDENTIFIER      reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    CALLOUT         reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)
    OPEN            reduce using rule 29 (statement -> WHILE O_PAR expr C_PAR block .)


state 123

    (47) arg -> expr COMMA arg .

    C_PAR           reduce using rule 47 (arg -> expr COMMA arg .)


state 124

    (59) callout_arg -> string_literal .

    NEGATIVE        reduce using rule 59 (callout_arg -> string_literal .)
    EXCL            reduce using rule 59 (callout_arg -> string_literal .)
    O_PAR           reduce using rule 59 (callout_arg -> string_literal .)
    STRING          reduce using rule 59 (callout_arg -> string_literal .)
    IDENTIFIER      reduce using rule 59 (callout_arg -> string_literal .)
    DECIMAL         reduce using rule 59 (callout_arg -> string_literal .)
    HEXDECIMAL      reduce using rule 59 (callout_arg -> string_literal .)
    CHAR            reduce using rule 59 (callout_arg -> string_literal .)
    TRUE            reduce using rule 59 (callout_arg -> string_literal .)
    FALSE           reduce using rule 59 (callout_arg -> string_literal .)
    COMMA           reduce using rule 59 (callout_arg -> string_literal .)


state 125

    (44) method_call -> CALLOUT O_PAR string_literal COMMA call . COMMA C_PAR

    COMMA           shift and go to state 129


state 126

    (56) call -> callout_arg .
    (57) call -> callout_arg . call
    (60) callout_arg -> callout_arg .
    (56) call -> . callout_arg
    (57) call -> . callout_arg call
    (58) callout_arg -> . expr
    (59) callout_arg -> . string_literal
    (60) callout_arg -> . callout_arg
    (50) expr -> . location
    (51) expr -> . literal
    (52) expr -> . expr bin_op expr
    (53) expr -> . NEGATIVE expr
    (54) expr -> . EXCL expr
    (55) expr -> . O_PAR expr C_PAR
    (73) string_literal -> . STRING
    (48) location -> . IDENTIFIER
    (49) location -> . IDENTIFIER O_BRACKET expr C_BRACKET
    (65) literal -> . int_literal
    (66) literal -> . char_literal
    (67) literal -> . bool_literal
    (68) int_literal -> . DECIMAL
    (69) int_literal -> . HEXDECIMAL
    (72) char_literal -> . CHAR
    (70) bool_literal -> . TRUE
    (71) bool_literal -> . FALSE

  ! reduce/reduce conflict for COMMA resolved using rule 56 (call -> callout_arg .)
  ! shift/reduce conflict for NEGATIVE resolved as shift
  ! shift/reduce conflict for EXCL resolved as shift
  ! shift/reduce conflict for O_PAR resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for DECIMAL resolved as shift
  ! shift/reduce conflict for HEXDECIMAL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    COMMA           reduce using rule 56 (call -> callout_arg .)
    NEGATIVE        shift and go to state 76
    EXCL            shift and go to state 77
    O_PAR           shift and go to state 78
    STRING          shift and go to state 109
    IDENTIFIER      shift and go to state 79
    DECIMAL         shift and go to state 31
    HEXDECIMAL      shift and go to state 32
    CHAR            shift and go to state 83
    TRUE            shift and go to state 84
    FALSE           shift and go to state 85

  ! NEGATIVE        [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! EXCL            [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! O_PAR           [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! STRING          [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! IDENTIFIER      [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! DECIMAL         [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! HEXDECIMAL      [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! CHAR            [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! TRUE            [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! FALSE           [ reduce using rule 60 (callout_arg -> callout_arg .) ]
  ! COMMA           [ reduce using rule 60 (callout_arg -> callout_arg .) ]

    callout_arg                    shift and go to state 126
    call                           shift and go to state 130
    expr                           shift and go to state 127
    string_literal                 shift and go to state 124
    location                       shift and go to state 74
    literal                        shift and go to state 75
    int_literal                    shift and go to state 80
    char_literal                   shift and go to state 81
    bool_literal                   shift and go to state 82

state 127

    (58) callout_arg -> expr .
    (52) expr -> expr . bin_op expr
    (61) bin_op -> . ARITH_OP
    (62) bin_op -> . REP_OP
    (63) bin_op -> . EQ_OP
    (64) bin_op -> . COND_OP

    NEGATIVE        reduce using rule 58 (callout_arg -> expr .)
    EXCL            reduce using rule 58 (callout_arg -> expr .)
    O_PAR           reduce using rule 58 (callout_arg -> expr .)
    STRING          reduce using rule 58 (callout_arg -> expr .)
    IDENTIFIER      reduce using rule 58 (callout_arg -> expr .)
    DECIMAL         reduce using rule 58 (callout_arg -> expr .)
    HEXDECIMAL      reduce using rule 58 (callout_arg -> expr .)
    CHAR            reduce using rule 58 (callout_arg -> expr .)
    TRUE            reduce using rule 58 (callout_arg -> expr .)
    FALSE           reduce using rule 58 (callout_arg -> expr .)
    COMMA           reduce using rule 58 (callout_arg -> expr .)
    ARITH_OP        shift and go to state 98
    REP_OP          shift and go to state 99
    EQ_OP           shift and go to state 100
    COND_OP         shift and go to state 101

    bin_op                         shift and go to state 97

state 128

    (28) statement -> IF O_PAR expr C_PAR block NEWLINE . else_or_empty
    (39) else_or_empty -> . ELSE block
    (40) else_or_empty -> . else_or_empty else_or_empty
    (41) else_or_empty -> . empty
    (74) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 132
    CLOSE           reduce using rule 74 (empty -> .)
    NEWLINE         reduce using rule 74 (empty -> .)
    IF              reduce using rule 74 (empty -> .)
    WHILE           reduce using rule 74 (empty -> .)
    RETURN          reduce using rule 74 (empty -> .)
    BREAK           reduce using rule 74 (empty -> .)
    CONTINUE        reduce using rule 74 (empty -> .)
    IDENTIFIER      reduce using rule 74 (empty -> .)
    CALLOUT         reduce using rule 74 (empty -> .)
    OPEN            reduce using rule 74 (empty -> .)

  ! ELSE            [ reduce using rule 74 (empty -> .) ]

    else_or_empty                  shift and go to state 131
    empty                          shift and go to state 133

state 129

    (44) method_call -> CALLOUT O_PAR string_literal COMMA call COMMA . C_PAR

    C_PAR           shift and go to state 134


state 130

    (57) call -> callout_arg call .

    COMMA           reduce using rule 57 (call -> callout_arg call .)


state 131

    (28) statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .
    (40) else_or_empty -> else_or_empty . else_or_empty
    (39) else_or_empty -> . ELSE block
    (40) else_or_empty -> . else_or_empty else_or_empty
    (41) else_or_empty -> . empty
    (74) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for CLOSE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for IF resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for CALLOUT resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
  ! reduce/reduce conflict for OPEN resolved using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    CLOSE           reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    NEWLINE         reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    IF              reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    WHILE           reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    RETURN          reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    BREAK           reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    CONTINUE        reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    IDENTIFIER      reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    CALLOUT         reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    OPEN            reduce using rule 28 (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty .)
    ELSE            shift and go to state 132

  ! ELSE            [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! IF              [ reduce using rule 74 (empty -> .) ]
  ! WHILE           [ reduce using rule 74 (empty -> .) ]
  ! RETURN          [ reduce using rule 74 (empty -> .) ]
  ! BREAK           [ reduce using rule 74 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 74 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 74 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 74 (empty -> .) ]
  ! OPEN            [ reduce using rule 74 (empty -> .) ]

    else_or_empty                  shift and go to state 135
    empty                          shift and go to state 133

state 132

    (39) else_or_empty -> ELSE . block
    (17) block -> . OPEN var_decl statement CLOSE
    (18) block -> . OPEN CLOSE

    OPEN            shift and go to state 40

    block                          shift and go to state 136

state 133

    (41) else_or_empty -> empty .

    ELSE            reduce using rule 41 (else_or_empty -> empty .)
    CLOSE           reduce using rule 41 (else_or_empty -> empty .)
    NEWLINE         reduce using rule 41 (else_or_empty -> empty .)
    IF              reduce using rule 41 (else_or_empty -> empty .)
    WHILE           reduce using rule 41 (else_or_empty -> empty .)
    RETURN          reduce using rule 41 (else_or_empty -> empty .)
    BREAK           reduce using rule 41 (else_or_empty -> empty .)
    CONTINUE        reduce using rule 41 (else_or_empty -> empty .)
    IDENTIFIER      reduce using rule 41 (else_or_empty -> empty .)
    CALLOUT         reduce using rule 41 (else_or_empty -> empty .)
    OPEN            reduce using rule 41 (else_or_empty -> empty .)


state 134

    (44) method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .

    SEMI            reduce using rule 44 (method_call -> CALLOUT O_PAR string_literal COMMA call COMMA C_PAR .)


state 135

    (40) else_or_empty -> else_or_empty else_or_empty .
    (40) else_or_empty -> else_or_empty . else_or_empty
    (39) else_or_empty -> . ELSE block
    (40) else_or_empty -> . else_or_empty else_or_empty
    (41) else_or_empty -> . empty
    (74) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for CLOSE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for IF resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for CALLOUT resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
  ! reduce/reduce conflict for OPEN resolved using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    CLOSE           reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    NEWLINE         reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    IF              reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    WHILE           reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    RETURN          reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    BREAK           reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    CONTINUE        reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    IDENTIFIER      reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    CALLOUT         reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    OPEN            reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .)
    ELSE            shift and go to state 132

  ! ELSE            [ reduce using rule 40 (else_or_empty -> else_or_empty else_or_empty .) ]
  ! ELSE            [ reduce using rule 74 (empty -> .) ]
  ! CLOSE           [ reduce using rule 74 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 74 (empty -> .) ]
  ! IF              [ reduce using rule 74 (empty -> .) ]
  ! WHILE           [ reduce using rule 74 (empty -> .) ]
  ! RETURN          [ reduce using rule 74 (empty -> .) ]
  ! BREAK           [ reduce using rule 74 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 74 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 74 (empty -> .) ]
  ! CALLOUT         [ reduce using rule 74 (empty -> .) ]
  ! OPEN            [ reduce using rule 74 (empty -> .) ]

    else_or_empty                  shift and go to state 135
    empty                          shift and go to state 133

state 136

    (39) else_or_empty -> ELSE block .

    ELSE            reduce using rule 39 (else_or_empty -> ELSE block .)
    CLOSE           reduce using rule 39 (else_or_empty -> ELSE block .)
    NEWLINE         reduce using rule 39 (else_or_empty -> ELSE block .)
    IF              reduce using rule 39 (else_or_empty -> ELSE block .)
    WHILE           reduce using rule 39 (else_or_empty -> ELSE block .)
    RETURN          reduce using rule 39 (else_or_empty -> ELSE block .)
    BREAK           reduce using rule 39 (else_or_empty -> ELSE block .)
    CONTINUE        reduce using rule 39 (else_or_empty -> ELSE block .)
    IDENTIFIER      reduce using rule 39 (else_or_empty -> ELSE block .)
    CALLOUT         reduce using rule 39 (else_or_empty -> ELSE block .)
    OPEN            reduce using rule 39 (else_or_empty -> ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 4 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 4 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 5 resolved as shift
WARNING: shift/reduce conflict for VOID in state 5 resolved as shift
WARNING: shift/reduce conflict for INT in state 5 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 5 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 10 resolved as shift
WARNING: shift/reduce conflict for INT in state 10 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 10 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 10 resolved as shift
WARNING: shift/reduce conflict for INT in state 10 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 10 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 11 resolved as shift
WARNING: shift/reduce conflict for VOID in state 11 resolved as shift
WARNING: shift/reduce conflict for CLOSE in state 11 resolved as shift
WARNING: shift/reduce conflict for INT in state 11 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 11 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 15 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 19 resolved as shift
WARNING: shift/reduce conflict for VOID in state 19 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 19 resolved as shift
WARNING: shift/reduce conflict for VOID in state 19 resolved as shift
WARNING: shift/reduce conflict for INT in state 19 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 19 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 29 resolved as shift
WARNING: shift/reduce conflict for INT in state 40 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 40 resolved as shift
WARNING: shift/reduce conflict for CLOSE in state 40 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 42 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 42 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 42 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 42 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 42 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 42 resolved as shift
WARNING: shift/reduce conflict for INT in state 42 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 42 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 46 resolved as shift
WARNING: shift/reduce conflict for INT in state 46 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 46 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 47 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 47 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 47 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 47 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 47 resolved as shift
WARNING: shift/reduce conflict for CLOSE in state 47 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 63 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 63 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 63 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 63 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 63 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 63 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 63 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 63 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 63 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 63 resolved as shift
WARNING: shift/reduce conflict for CALLOUT in state 63 resolved as shift
WARNING: shift/reduce conflict for OPEN in state 63 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 102 resolved as shift
WARNING: shift/reduce conflict for REP_OP in state 102 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 102 resolved as shift
WARNING: shift/reduce conflict for COND_OP in state 102 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 103 resolved as shift
WARNING: shift/reduce conflict for REP_OP in state 103 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 103 resolved as shift
WARNING: shift/reduce conflict for COND_OP in state 103 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 110 resolved as shift
WARNING: shift/reduce conflict for ARITH_OP in state 114 resolved as shift
WARNING: shift/reduce conflict for REP_OP in state 114 resolved as shift
WARNING: shift/reduce conflict for EQ_OP in state 114 resolved as shift
WARNING: shift/reduce conflict for COND_OP in state 114 resolved as shift
WARNING: shift/reduce conflict for NEGATIVE in state 126 resolved as shift
WARNING: shift/reduce conflict for EXCL in state 126 resolved as shift
WARNING: shift/reduce conflict for O_PAR in state 126 resolved as shift
WARNING: shift/reduce conflict for STRING in state 126 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 126 resolved as shift
WARNING: shift/reduce conflict for DECIMAL in state 126 resolved as shift
WARNING: shift/reduce conflict for HEXDECIMAL in state 126 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 126 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 126 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 126 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 128 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 131 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 135 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 135 resolved as shift
WARNING: reduce/reduce conflict in state 10 resolved using rule (field_decl -> field_decl field_decl)
WARNING: rejected rule (empty -> <empty>) in state 10
WARNING: reduce/reduce conflict in state 14 resolved using rule (field_decl -> empty)
WARNING: rejected rule (method_decl -> empty) in state 14
WARNING: reduce/reduce conflict in state 19 resolved using rule (method_decl -> method_decl method_decl)
WARNING: rejected rule (empty -> <empty>) in state 19
WARNING: reduce/reduce conflict in state 56 resolved using rule (var_decl -> empty)
WARNING: rejected rule (statement -> empty) in state 56
WARNING: reduce/reduce conflict in state 63 resolved using rule (statement -> statement statement)
WARNING: rejected rule (empty -> <empty>) in state 63
WARNING: reduce/reduce conflict in state 126 resolved using rule (call -> callout_arg)
WARNING: rejected rule (callout_arg -> callout_arg) in state 126
WARNING: reduce/reduce conflict in state 131 resolved using rule (statement -> IF O_PAR expr C_PAR block NEWLINE else_or_empty)
WARNING: rejected rule (empty -> <empty>) in state 131
WARNING: reduce/reduce conflict in state 135 resolved using rule (else_or_empty -> else_or_empty else_or_empty)
WARNING: rejected rule (empty -> <empty>) in state 135
WARNING: Rule (callout_arg -> callout_arg) is never reduced
